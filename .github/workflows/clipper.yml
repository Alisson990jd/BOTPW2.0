name: üé¨ Create YouTube Clips

on:
  workflow_dispatch:
    inputs:
      vod_link:
        description: 'üîó Link do VOD da Twitch'
        required: true
        type: string
      password:
        description: 'üîê Senha para executar'
        required: true
        type: string

env:
  PYTHONUNBUFFERED: "1"

jobs:
  validate:
    name: üîê Validar Senha
    runs-on: ubuntu-latest
    outputs:
      valid: ${{ steps.check.outputs.valid }}
    steps:
      - name: Verificar senha
        id: check
        run: |
          if [ "${{ github.event.inputs.password }}" = "${{ secrets.SENHA }}" ]; then
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Senha v√°lida!"
          else
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "‚ùå Senha inv√°lida!"
            exit 1
          fi

  create-clips:
    name: üé¨ Processar Clipes
    needs: validate
    if: needs.validate.outputs.valid == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 360
    
    steps:
      - name: üì• Checkout do reposit√≥rio
        uses: actions/checkout@v4

      - name: üìù Criar requirements.txt
        run: |
          cat > requirements.txt << 'EOF'
          google-api-python-client
          google-auth
          google-auth-oauthlib
          google-auth-httplib2
          requests
          yt-dlp
          EOF
          echo "‚úÖ requirements.txt criado!"

      - name: üêç Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: üì¶ Instalar depend√™ncias do sistema
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg aria2
          aria2c --version | head -1
          
      - name: üì¶ Instalar depend√™ncias Python
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: üì• Baixar configura√ß√µes do reposit√≥rio externo
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          echo "üì• Baixando analise_resultado.json..."
          curl -H "Authorization: token $GH_PAT" \
               -H "Accept: application/vnd.github.v3.raw" \
               -o analise_resultado.json \
               "https://api.github.com/repos/Alisson990jd/apiss/contents/analise_resultado.json"
          
          echo "üì• Baixando gmail_token.pkl..."
          curl -H "Authorization: token $GH_PAT" \
               -H "Accept: application/vnd.github.v3.raw" \
               -o gmail_token.pkl \
               "https://api.github.com/repos/Alisson990jd/apiss/contents/gmail_token.pkl"
          
          echo "üì• Baixando arquivos da pasta analisar..."
          mkdir -p analisar
          
          FILES=$(curl -s -H "Authorization: token $GH_PAT" \
                       -H "Accept: application/vnd.github.v3+json" \
                       "https://api.github.com/repos/Alisson990jd/apiss/contents/analisar" | \
                  jq -r '.[] | select(.name | endswith(".json")) | .name')
          
          for FILE in $FILES; do
            echo "  üìÑ Baixando $FILE..."
            curl -s -H "Authorization: token $GH_PAT" \
                 -H "Accept: application/vnd.github.v3.raw" \
                 -o "analisar/$FILE" \
                 "https://api.github.com/repos/Alisson990jd/apiss/contents/analisar/$FILE"
          done
          
          PKL_FILES=$(curl -s -H "Authorization: token $GH_PAT" \
                       -H "Accept: application/vnd.github.v3+json" \
                       "https://api.github.com/repos/Alisson990jd/apiss/contents/analisar" | \
                  jq -r '.[] | select(.name | endswith(".pkl")) | .name')
          
          for FILE in $PKL_FILES; do
            echo "  üìÑ Baixando $FILE..."
            curl -s -H "Authorization: token $GH_PAT" \
                 -H "Accept: application/vnd.github.v3.raw" \
                 -o "analisar/$FILE" \
                 "https://api.github.com/repos/Alisson990jd/apiss/contents/analisar/$FILE"
          done
          
          echo "‚úÖ Configura√ß√µes baixadas!"
          ls -la analisar/
          
          echo "‚úÖ Todos os arquivos baixados!"

      - name: üìÇ Criar diret√≥rios
        run: |
          mkdir -p scripts temp_clips

      - name: üìù Criar script otimizado
        run: |
          cat > scripts/clip_creator.py << 'SCRIPT_EOF'
          #!/usr/bin/env python3
          """
          üé¨ YouTube Clip Creator
          """

          import os
          import sys
          import json
          import subprocess
          import pickle
          import time
          import logging
          import requests
          from pathlib import Path
          from datetime import datetime, timezone
          from typing import Optional, Dict, List

          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s | %(levelname)s | %(message)s',
              handlers=[
                  logging.StreamHandler(sys.stdout),
                  logging.FileHandler('clip_creator.log')
              ]
          )
          logger = logging.getLogger(__name__)

          TEMP_DIR = Path("temp_clips")
          PROCESSING_LOG = "processing_log.json"


          def time_to_seconds(time_str: str) -> int:
              parts = time_str.split(':')
              if len(parts) == 3:
                  h, m, s = map(int, parts)
                  return h * 3600 + m * 60 + s
              elif len(parts) == 2:
                  m, s = map(int, parts)
                  return m * 60 + s
              return int(parts[0])


          def seconds_to_time(seconds: int) -> str:
              h = seconds // 3600
              m = (seconds % 3600) // 60
              s = seconds % 60
              return f"{h:02d}:{m:02d}:{s:02d}"



          def load_clips_config() -> List[Dict]:
              logger.info("üìÇ Carregando configura√ß√£o de clipes...")
              with open("analise_resultado.json", "r", encoding="utf-8") as f:
                  data = json.load(f)
              clips = data.get("clips", [])
              youtube_clips = [c for c in clips if c.get("platform") == "youtube"]
              logger.info(f"   Total: {len(clips)} | YouTube: {len(youtube_clips)}")
              return youtube_clips


          def load_youtube_credentials() -> Dict:
              logger.info("üîë Carregando credenciais...")
              analisar_dir = Path("analisar")
              json_files = list(analisar_dir.glob("*.json"))
              if not json_files:
                  raise FileNotFoundError("Nenhuma credencial encontrada!")
              
              cred_file = json_files[0]
              with open(cred_file, "r", encoding="utf-8") as f:
                  cred_data = json.load(f)
              
              pkl_files = list(analisar_dir.glob("*.pkl"))
              if not pkl_files:
                  raise FileNotFoundError("Arquivo pkl n√£o encontrado!")
              
              logger.info(f"   ‚úÖ Usando: {pkl_files[0].name}")
              return {"json_data": cred_data, "pkl_file": pkl_files[0]}


          def download_clip_segment_fast(vod_url: str, start_time: str, end_time: str, output_path: Path) -> bool:
              """Download ULTRA R√ÅPIDO usando aria2c"""
              logger.info(f"‚¨áÔ∏è  Download: {start_time} -> {end_time}")
              
              aria2_args = [
                  "--max-connection-per-server=16",
                  "--split=16",
                  "--min-split-size=1M",
                  "--max-concurrent-downloads=16",
                  "--file-allocation=none",
                  "--continue=true",
                  "--max-tries=5",
                  "--retry-wait=2",
                  "--timeout=60",
                  "--connect-timeout=30",
                  "--console-log-level=warn",
              ]
              
              cmd = [
                  "yt-dlp",
                  "--format", "bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo+bestaudio/best",
                  "--download-sections", f"*{start_time}-{end_time}",
                  "--downloader", "aria2c",
                  "--downloader-args", f"aria2c:{' '.join(aria2_args)}",
                  "--concurrent-fragments", "16",
                  "--no-part",
                  "--no-mtime",
                  "--no-check-certificates",
                  "--merge-output-format", "mp4",
                  "--output", str(output_path),
                  "--progress",
                  vod_url
              ]
              
              try:
                  start = time.time()
                  result = subprocess.run(cmd, capture_output=True, text=True, timeout=1200)
                  elapsed = time.time() - start
                  
                  if result.returncode == 0 and output_path.exists():
                      size_mb = output_path.stat().st_size / (1024 * 1024)
                      speed = size_mb / elapsed if elapsed > 0 else 0
                      logger.info(f"   ‚úÖ Baixado: {size_mb:.1f}MB em {elapsed:.1f}s ({speed:.1f} MB/s)")
                      return True
                  else:
                      logger.warning(f"   ‚ö†Ô∏è aria2c falhou, tentando fallback...")
                      return download_clip_fallback(vod_url, start_time, end_time, output_path)
                      
              except subprocess.TimeoutExpired:
                  logger.error("   ‚ùå Timeout")
                  return False
              except Exception as e:
                  logger.error(f"   ‚ùå Erro: {e}")
                  return download_clip_fallback(vod_url, start_time, end_time, output_path)


          def download_clip_fallback(vod_url: str, start_time: str, end_time: str, output_path: Path) -> bool:
              """Fallback sem aria2c"""
              cmd = [
                  "yt-dlp",
                  "--format", "best[ext=mp4]/best",
                  "--download-sections", f"*{start_time}-{end_time}",
                  "--concurrent-fragments", "8",
                  "--no-part",
                  "--merge-output-format", "mp4",
                  "--output", str(output_path),
                  vod_url
              ]
              
              try:
                  result = subprocess.run(cmd, capture_output=True, text=True, timeout=1200)
                  if result.returncode == 0 and output_path.exists():
                      size_mb = output_path.stat().st_size / (1024 * 1024)
                      logger.info(f"   ‚úÖ Fallback OK: {size_mb:.1f}MB")
                      return True
                  return False
              except:
                  return False



          def upload_to_youtube(video_path: Path, clip_data: Dict, credentials: Dict) -> Optional[str]:
              """Upload para YouTube"""
              logger.info("üì§ Upload para YouTube...")
              
              try:
                  from google.auth.transport.requests import Request
                  from googleapiclient.discovery import build
                  from googleapiclient.http import MediaFileUpload
                  from googleapiclient.errors import HttpError
                  
                  with open(credentials["pkl_file"], 'rb') as f:
                      creds = pickle.load(f)
                  
                  if creds and creds.expired and creds.refresh_token:
                      logger.info("   üîÑ Renovando token...")
                      creds.refresh(Request())
                      with open(credentials["pkl_file"], 'wb') as f:
                          pickle.dump(creds, f)
                  
                  service = build('youtube', 'v3', credentials=creds)
                  
                  # Verificar canal
                  try:
                      channel_response = service.channels().list(part='snippet,status', mine=True).execute()
                      if channel_response.get('items'):
                          channel = channel_response['items'][0]
                          logger.info(f"   üì∫ Canal: {channel['snippet']['title']}")
                  except Exception as e:
                      logger.warning(f"   ‚ö†Ô∏è N√£o foi poss√≠vel verificar canal: {e}")
                  
                  category_map = {"gaming": "20", "entertainment": "24", "IRL": "22", "react": "24"}
                  category_id = category_map.get(clip_data.get("category", "").lower(), "22")
                  
                  title = clip_data.get("title", "Clip")[:100]
                  description = clip_data.get("recommended_description", "")[:5000]
                  tags = clip_data.get("tags", [])[:500]
                  
                  logger.info(f"   üìù T√≠tulo: {title}")
                  
                  body = {
                      'snippet': {
                          'title': title,
                          'description': description,
                          'tags': tags,
                          'categoryId': category_id,
                      },
                      'status': {
                          'privacyStatus': 'private',
                          'selfDeclaredMadeForKids': False,
                      }
                  }
                  
                  # Upload do v√≠deo
                  media = MediaFileUpload(
                      str(video_path), 
                      chunksize=10*1024*1024, 
                      resumable=True, 
                      mimetype='video/mp4'
                  )
                  
                  request = service.videos().insert(
                      part=','.join(body.keys()), 
                      body=body, 
                      media_body=media
                  )
                  
                  response = None
                  while response is None:
                      status, response = request.next_chunk()
                      if status:
                          progress = int(status.progress() * 100)
                          logger.info(f"   üì§ Upload: {progress}%")
                  
                  video_id = response.get('id')
                  
                  if not video_id:
                      logger.error("   ‚ùå Nenhum video_id retornado!")
                      return None
                  
                  logger.info(f"   ‚úÖ V√≠deo enviado: {video_id}")
                  logger.info(f"   üîó https://youtube.com/watch?v={video_id}")
                  
                  
                  return video_id
                  
              except HttpError as e:
                  logger.error(f"   ‚ùå Erro HTTP: {e.resp.status} - {e.content.decode()}")
                  return None
              except Exception as e:
                  logger.error(f"   ‚ùå Erro: {type(e).__name__}: {e}")
                  import traceback
                  traceback.print_exc()
                  return None


          def process_clip(clip_data: Dict, vod_url: str, credentials: Dict, idx: int, total: int) -> Dict:
              clip_id = clip_data.get("clip_id", f"clip_{idx}")
              
              logger.info("")
              logger.info("=" * 60)
              logger.info(f"üé¨ [{idx+1}/{total}] {clip_id}")
              logger.info(f"   üìù {clip_data.get('title', 'N/A')[:60]}...")
              logger.info(f"   ‚è±Ô∏è  {clip_data.get('start_time')} ‚Üí {clip_data.get('end_time')}")
              logger.info("=" * 60)
              
              result = {
                  "clip_id": clip_id, 
                  "title": clip_data.get("title"), 
                  "status": "pending", 
                  "video_id": None, 
                  "error": None
              }
              
              video_path = TEMP_DIR / f"{clip_id}.mp4"
              
              try:
                  # 1. Download do clipe
                  if not download_clip_segment_fast(
                      vod_url, 
                      clip_data.get("start_time"), 
                      clip_data.get("end_time"), 
                      video_path
                  ):
                      result["status"] = "failed"
                      result["error"] = "Download falhou"
                      return result
                  
                  # 2. Upload para YouTube
                  video_id = upload_to_youtube(
                      video_path, 
                      clip_data, 
                      credentials
                  )
                  
                  if video_id:
                      result["status"] = "success"
                      result["video_id"] = video_id
                      result["url"] = f"https://youtube.com/watch?v={video_id}"
                  else:
                      result["status"] = "failed"
                      result["error"] = "Upload falhou"
                  
              except Exception as e:
                  result["status"] = "error"
                  result["error"] = str(e)
                  logger.error(f"   ‚ùå {e}")
                  import traceback
                  traceback.print_exc()
                  
              finally:
                  # Limpar v√≠deo tempor√°rio
                  try:
                      if video_path.exists():
                          video_path.unlink()
                          logger.info(f"   üóëÔ∏è V√≠deo removido")
                  except:
                      pass
              
              return result


          def main():
              logger.info("")
              logger.info("=" * 60)
              logger.info("üé¨ YOUTUBE CLIP CREATOR")
              logger.info("=" * 60)
              
              if len(sys.argv) < 2:
                  logger.error("‚ùå Uso: python clip_creator.py <VOD_URL>")
                  sys.exit(1)
              
              vod_url = sys.argv[1]
              logger.info(f"üìπ VOD: {vod_url}")
              
              TEMP_DIR.mkdir(exist_ok=True)
              
              try:
                  clips = load_clips_config()
                  creds = load_youtube_credentials()
              except Exception as e:
                  logger.error(f"‚ùå {e}")
                  import traceback
                  traceback.print_exc()
                  sys.exit(1)
              
              if not clips:
                  logger.warning("‚ö†Ô∏è Nenhum clipe YouTube!")
                  sys.exit(0)
              
              logger.info(f"üìã {len(clips)} clipes para processar")
              
              results = []
              total = len(clips)
              
              for i, clip in enumerate(clips):
                  result = process_clip(clip, vod_url, creds, i, total)
                  results.append(result)
                  
                  if result["status"] == "success" and i < total - 1:
                      logger.info("‚è≥ Aguardando 5s...")
                      time.sleep(5)
              
              # Salvar log
              summary = {
                  "processed_at": datetime.now().isoformat(),
                  "total": len(results),
                  "success": len([r for r in results if r["status"] == "success"]),
                  "failed": len([r for r in results if r["status"] != "success"]),
                  "clips": results
              }
              
              with open(PROCESSING_LOG, "w") as f:
                  json.dump(summary, f, indent=2, ensure_ascii=False)
              
              logger.info("")
              logger.info("=" * 60)
              logger.info("üìä RESUMO FINAL")
              logger.info("=" * 60)
              logger.info(f"   üìπ V√≠deos: {summary['success']}/{summary['total']} sucesso")
              logger.info(f"   ‚ùå Falhas: {summary['failed']}")
              logger.info("=" * 60)
              
              # Lista v√≠deos enviados
              logger.info("")
              logger.info("üì∫ V√çDEOS ENVIADOS:")
              for r in results:
                  if r["status"] == "success":
                      logger.info(f"   ‚úÖ {r['title'][:50]}...")
                      logger.info(f"      {r.get('url', 'N/A')}")


          if __name__ == "__main__":
              main()
          SCRIPT_EOF
          
          chmod +x scripts/clip_creator.py

      - name: üé¨ Processar Clipes
        env:
          VOD_LINK: ${{ github.event.inputs.vod_link }}

        run: |
          python scripts/clip_creator.py "$VOD_LINK"

      - name: üìä Resumo
        if: always()
        run: |
          echo "## üìä Resumo" >> $GITHUB_STEP_SUMMARY
          if [ -f "processing_log.json" ]; then
            echo '```json' >> $GITHUB_STEP_SUMMARY
            cat processing_log.json >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi
          


      - name: üì§ Upload logs e thumbnails
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: logs
          path: |
            *.log
            processing_log.json
          retention-days: 7
