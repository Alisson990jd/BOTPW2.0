name: üé¨ Create YouTube Clips

on:
  workflow_dispatch:
    inputs:
      vod_link:
        description: 'üîó Link do VOD da Twitch'
        required: true
        type: string
      password:
        description: 'üîê Senha para executar'
        required: true
        type: string

env:
  PYTHONUNBUFFERED: "1"

jobs:
  validate:
    name: üîê Validar Senha
    runs-on: ubuntu-latest
    outputs:
      valid: ${{ steps.check.outputs.valid }}
    steps:
      - name: Verificar senha
        id: check
        run: |
          if [ "${{ github.event.inputs.password }}" = "${{ secrets.SENHA }}" ]; then
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Senha v√°lida!"
          else
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "‚ùå Senha inv√°lida!"
            exit 1
          fi

  create-clips:
    name: üé¨ Processar Clipes
    needs: validate
    if: needs.validate.outputs.valid == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 360
    
    steps:
      - name: üì• Checkout do reposit√≥rio
        uses: actions/checkout@v4

      - name: üìù Criar requirements.txt
        run: |
          cat > requirements.txt << 'EOF'
          google-api-python-client>=2.100.0
          google-auth>=2.23.0
          google-auth-oauthlib>=1.1.0
          google-auth-httplib2>=0.1.1
          requests>=2.31.0
          yt-dlp>=2024.1.0
          EOF
          echo "‚úÖ requirements.txt criado!"

      - name: üêç Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: üì¶ Instalar depend√™ncias do sistema
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg aria2
          
          # Verificar aria2
          aria2c --version | head -1
          echo "‚úÖ aria2 instalado!"
          
      - name: üì¶ Instalar depend√™ncias Python
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: üì• Baixar configura√ß√µes do reposit√≥rio externo
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          echo "üì• Baixando analise_resultado.json..."
          curl -H "Authorization: token $GH_PAT" \
               -H "Accept: application/vnd.github.v3.raw" \
               -o analise_resultado.json \
               "https://api.github.com/repos/Alisson990jd/apiss/contents/analise_resultado.json"
          
          echo "üì• Baixando gmail_token.pkl..."
          curl -H "Authorization: token $GH_PAT" \
               -H "Accept: application/vnd.github.v3.raw" \
               -o gmail_token.pkl \
               "https://api.github.com/repos/Alisson990jd/apiss/contents/gmail_token.pkl"
          
          echo "üì• Baixando arquivos da pasta analisar..."
          mkdir -p analisar
          
          # Listar e baixar arquivos JSON
          FILES=$(curl -s -H "Authorization: token $GH_PAT" \
                       -H "Accept: application/vnd.github.v3+json" \
                       "https://api.github.com/repos/Alisson990jd/apiss/contents/analisar" | \
                  jq -r '.[] | select(.name | endswith(".json")) | .name')
          
          for FILE in $FILES; do
            echo "  üìÑ Baixando $FILE..."
            curl -s -H "Authorization: token $GH_PAT" \
                 -H "Accept: application/vnd.github.v3.raw" \
                 -o "analisar/$FILE" \
                 "https://api.github.com/repos/Alisson990jd/apiss/contents/analisar/$FILE"
          done
          
          # Baixar arquivos PKL
          PKL_FILES=$(curl -s -H "Authorization: token $GH_PAT" \
                       -H "Accept: application/vnd.github.v3+json" \
                       "https://api.github.com/repos/Alisson990jd/apiss/contents/analisar" | \
                  jq -r '.[] | select(.name | endswith(".pkl")) | .name')
          
          for FILE in $PKL_FILES; do
            echo "  üìÑ Baixando $FILE..."
            curl -s -H "Authorization: token $GH_PAT" \
                 -H "Accept: application/vnd.github.v3.raw" \
                 -o "analisar/$FILE" \
                 "https://api.github.com/repos/Alisson990jd/apiss/contents/analisar/$FILE"
          done
          
          echo "‚úÖ Configura√ß√µes baixadas!"
          ls -la analisar/

      - name: üìÇ Criar diret√≥rios
        run: |
          mkdir -p scripts temp_clips

      - name: üìù Criar script otimizado
        run: |
          cat > scripts/clip_creator.py << 'SCRIPT_EOF'
          #!/usr/bin/env python3
          """
          üé¨ YouTube Clip Creator - OTIMIZADO PARA VELOCIDADE
          """

          import os
          import sys
          import json
          import subprocess
          import pickle
          import time
          import logging
          from pathlib import Path
          from datetime import datetime
          from typing import Optional, Dict, List
          from concurrent.futures import ThreadPoolExecutor, as_completed

          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s | %(levelname)s | %(message)s',
              handlers=[
                  logging.StreamHandler(sys.stdout),
                  logging.FileHandler('clip_creator.log')
              ]
          )
          logger = logging.getLogger(__name__)

          TEMP_DIR = Path("temp_clips")
          PROCESSING_LOG = "processing_log.json"


          def time_to_seconds(time_str: str) -> int:
              parts = time_str.split(':')
              if len(parts) == 3:
                  h, m, s = map(int, parts)
                  return h * 3600 + m * 60 + s
              elif len(parts) == 2:
                  m, s = map(int, parts)
                  return m * 60 + s
              return int(parts[0])


          def seconds_to_time(seconds: int) -> str:
              h = seconds // 3600
              m = (seconds % 3600) // 60
              s = seconds % 60
              return f"{h:02d}:{m:02d}:{s:02d}"


          def load_clips_config() -> List[Dict]:
              logger.info("üìÇ Carregando configura√ß√£o de clipes...")
              with open("analise_resultado.json", "r", encoding="utf-8") as f:
                  data = json.load(f)
              clips = data.get("clips", [])
              youtube_clips = [c for c in clips if c.get("platform") == "youtube"]
              logger.info(f"   Total: {len(clips)} | YouTube: {len(youtube_clips)}")
              return youtube_clips


          def load_youtube_credentials() -> Dict:
              logger.info("üîë Carregando credenciais...")
              analisar_dir = Path("analisar")
              json_files = list(analisar_dir.glob("*.json"))
              if not json_files:
                  raise FileNotFoundError("Nenhuma credencial encontrada!")
              
              cred_file = json_files[0]
              with open(cred_file, "r", encoding="utf-8") as f:
                  cred_data = json.load(f)
              
              pkl_files = list(analisar_dir.glob("*.pkl"))
              if not pkl_files:
                  raise FileNotFoundError("Arquivo pkl n√£o encontrado!")
              
              logger.info(f"   ‚úÖ Usando: {pkl_files[0].name}")
              return {"json_data": cred_data, "pkl_file": pkl_files[0]}


          def download_clip_segment_fast(vod_url: str, start_time: str, end_time: str, output_path: Path) -> bool:
              """
              Download ULTRA R√ÅPIDO usando aria2c com m√∫ltiplas conex√µes
              """
              logger.info(f"‚¨áÔ∏è  Download r√°pido: {start_time} -> {end_time}")
              
              # Configura√ß√µes aria2c para m√°xima velocidade
              aria2_args = [
                  "--max-connection-per-server=16",  # 16 conex√µes por servidor
                  "--split=16",                       # Dividir em 16 partes
                  "--min-split-size=1M",             # M√≠nimo 1MB por parte
                  "--max-concurrent-downloads=16",   # 16 downloads simult√¢neos
                  "--file-allocation=none",          # Sem pr√©-aloca√ß√£o (mais r√°pido)
                  "--continue=true",                 # Continuar downloads interrompidos
                  "--max-tries=5",                   # 5 tentativas
                  "--retry-wait=2",                  # 2 segundos entre tentativas
                  "--timeout=60",                    # Timeout de 60s
                  "--connect-timeout=30",            # Timeout de conex√£o 30s
                  "--summary-interval=0",            # Sem resumo (menos output)
                  "--console-log-level=warn",        # Menos logs
              ]
              
              cmd = [
                  "yt-dlp",
                  # Formato: melhor qualidade dispon√≠vel
                  "--format", "bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo+bestaudio/best",
                  
                  # Segmento espec√≠fico
                  "--download-sections", f"*{start_time}-{end_time}",
                  
                  # Usar aria2c como downloader externo (MUITO mais r√°pido)
                  "--downloader", "aria2c",
                  "--downloader-args", f"aria2c:{' '.join(aria2_args)}",
                  
                  # Otimiza√ß√µes de velocidade
                  "--concurrent-fragments", "16",
                  "--no-part",
                  "--no-mtime",
                  "--no-check-certificates",
                  
                  # Output
                  "--merge-output-format", "mp4",
                  "--output", str(output_path),
                  
                  # Silenciar um pouco
                  "--no-warnings",
                  "--progress",
                  
                  vod_url
              ]
              
              try:
                  start = time.time()
                  result = subprocess.run(
                      cmd, 
                      capture_output=True, 
                      text=True, 
                      timeout=1200  # 20 min timeout
                  )
                  elapsed = time.time() - start
                  
                  if result.returncode == 0 and output_path.exists():
                      size_mb = output_path.stat().st_size / (1024 * 1024)
                      speed = size_mb / elapsed if elapsed > 0 else 0
                      logger.info(f"   ‚úÖ Baixado: {size_mb:.1f}MB em {elapsed:.1f}s ({speed:.1f} MB/s)")
                      return True
                  else:
                      # Fallback sem aria2c
                      logger.warning(f"   ‚ö†Ô∏è aria2c falhou, tentando fallback...")
                      return download_clip_fallback(vod_url, start_time, end_time, output_path)
                      
              except subprocess.TimeoutExpired:
                  logger.error("   ‚ùå Timeout no download")
                  return False
              except Exception as e:
                  logger.error(f"   ‚ùå Erro: {e}")
                  return download_clip_fallback(vod_url, start_time, end_time, output_path)


          def download_clip_fallback(vod_url: str, start_time: str, end_time: str, output_path: Path) -> bool:
              """Fallback sem aria2c"""
              logger.info("   üîÑ Tentando download alternativo...")
              
              cmd = [
                  "yt-dlp",
                  "--format", "best[ext=mp4]/best",
                  "--download-sections", f"*{start_time}-{end_time}",
                  "--concurrent-fragments", "8",
                  "--no-part",
                  "--merge-output-format", "mp4",
                  "--output", str(output_path),
                  vod_url
              ]
              
              try:
                  result = subprocess.run(cmd, capture_output=True, text=True, timeout=1200)
                  if result.returncode == 0 and output_path.exists():
                      size_mb = output_path.stat().st_size / (1024 * 1024)
                      logger.info(f"   ‚úÖ Fallback OK: {size_mb:.1f}MB")
                      return True
                  return False
              except:
                  return False


          def capture_thumbnail_fast(video_path: Path, timestamp: str, output_path: Path) -> bool:
              """Captura frame rapidamente"""
              cmd = [
                  "ffmpeg", "-y",
                  "-ss", timestamp,
                  "-i", str(video_path),
                  "-vframes", "1",
                  "-q:v", "2",
                  "-f", "image2",
                  str(output_path)
              ]
              try:
                  result = subprocess.run(cmd, capture_output=True, timeout=30)
                  return result.returncode == 0 and output_path.exists()
              except:
                  return False


          def upload_to_youtube(video_path: Path, thumb_path: Optional[Path], clip_data: Dict, credentials: Dict) -> Optional[str]:
              logger.info("üì§ Upload para YouTube...")
              
              try:
                  from google.auth.transport.requests import Request
                  from googleapiclient.discovery import build
                  from googleapiclient.http import MediaFileUpload
                  
                  with open(credentials["pkl_file"], 'rb') as f:
                      creds = pickle.load(f)
                  
                  if creds and creds.expired and creds.refresh_token:
                      creds.refresh(Request())
                      with open(credentials["pkl_file"], 'wb') as f:
                          pickle.dump(creds, f)
                  
                  service = build('youtube', 'v3', credentials=creds)
                  
                  category_map = {"gaming": "20", "entertainment": "24", "IRL": "22", "react": "24"}
                  category_id = category_map.get(clip_data.get("category", "").lower(), "22")
                  
                  body = {
                      'snippet': {
                          'title': clip_data.get("title", "Clip")[:100],
                          'description': clip_data.get("recommended_description", "")[:5000],
                          'tags': clip_data.get("tags", [])[:500],
                          'categoryId': category_id,
                      },
                      'status': {
                          'privacyStatus': 'private',
                          'selfDeclaredMadeForKids': False,
                      }
                  }
                  
                  media = MediaFileUpload(str(video_path), chunksize=10*1024*1024, resumable=True, mimetype='video/mp4')
                  request = service.videos().insert(part=','.join(body.keys()), body=body, media_body=media)
                  
                  response = None
                  while response is None:
                      status, response = request.next_chunk()
                      if status:
                          logger.info(f"   Upload: {int(status.progress() * 100)}%")
                  
                  video_id = response.get('id')
                  
                  if video_id and thumb_path and thumb_path.exists():
                      try:
                          thumb_media = MediaFileUpload(str(thumb_path), mimetype='image/png')
                          service.thumbnails().set(videoId=video_id, media_body=thumb_media).execute()
                          logger.info("   ‚úÖ Thumbnail OK!")
                      except Exception as e:
                          logger.warning(f"   ‚ö†Ô∏è Thumb erro: {e}")
                  
                  if video_id:
                      logger.info(f"   ‚úÖ https://youtube.com/watch?v={video_id}")
                  
                  return video_id
                  
              except Exception as e:
                  logger.error(f"   ‚ùå Erro: {e}")
                  return None


          def process_clip(clip_data: Dict, vod_url: str, credentials: Dict, idx: int, total: int) -> Dict:
              clip_id = clip_data.get("clip_id", f"clip_{idx}")
              
              logger.info("")
              logger.info("=" * 50)
              logger.info(f"üé¨ [{idx+1}/{total}] {clip_id}")
              logger.info(f"   {clip_data.get('title', 'N/A')[:50]}...")
              logger.info(f"   ‚è±Ô∏è {clip_data.get('start_time')} ‚Üí {clip_data.get('end_time')}")
              logger.info("=" * 50)
              
              result = {"clip_id": clip_id, "title": clip_data.get("title"), "status": "pending", "video_id": None, "error": None}
              
              video_path = TEMP_DIR / f"{clip_id}.mp4"
              frame_path = TEMP_DIR / f"{clip_id}_thumb.png"
              
              try:
                  # Download
                  if not download_clip_segment_fast(vod_url, clip_data.get("start_time"), clip_data.get("end_time"), video_path):
                      result["status"] = "failed"
                      result["error"] = "Download falhou"
                      return result
                  
                  # Thumbnail
                  thumb_ts = clip_data.get("thumbnail_timestamp", clip_data.get("start_time"))
                  start_sec = time_to_seconds(clip_data.get("start_time", "00:00:00"))
                  thumb_sec = time_to_seconds(thumb_ts)
                  rel_thumb = seconds_to_time(max(0, thumb_sec - start_sec))
                  capture_thumbnail_fast(video_path, rel_thumb, frame_path)
                  
                  # Upload
                  video_id = upload_to_youtube(video_path, frame_path if frame_path.exists() else None, clip_data, credentials)
                  
                  if video_id:
                      result["status"] = "success"
                      result["video_id"] = video_id
                  else:
                      result["status"] = "failed"
                      result["error"] = "Upload falhou"
                  
              except Exception as e:
                  result["status"] = "error"
                  result["error"] = str(e)
                  logger.error(f"   ‚ùå {e}")
              finally:
                  # Limpar
                  for p in [video_path, frame_path]:
                      try:
                          if p.exists():
                              p.unlink()
                      except:
                          pass
              
              return result


          def main():
              logger.info("=" * 50)
              logger.info("üé¨ YOUTUBE CLIP CREATOR - TURBO MODE")
              logger.info("=" * 50)
              
              if len(sys.argv) < 2:
                  logger.error("‚ùå Uso: python clip_creator.py <VOD_URL>")
                  sys.exit(1)
              
              vod_url = sys.argv[1]
              logger.info(f"üìπ VOD: {vod_url}")
              
              TEMP_DIR.mkdir(exist_ok=True)
              
              try:
                  clips = load_clips_config()
                  creds = load_youtube_credentials()
              except Exception as e:
                  logger.error(f"‚ùå {e}")
                  sys.exit(1)
              
              if not clips:
                  logger.warning("‚ö†Ô∏è Nenhum clipe YouTube!")
                  sys.exit(0)
              
              results = []
              total = len(clips)
              
              for i, clip in enumerate(clips):
                  result = process_clip(clip, vod_url, creds, i, total)
                  results.append(result)
                  
                  if result["status"] == "success" and i < total - 1:
                      logger.info("‚è≥ Aguardando 5s...")
                      time.sleep(5)
              
              # Salvar log
              summary = {
                  "processed_at": datetime.now().isoformat(),
                  "total": len(results),
                  "success": len([r for r in results if r["status"] == "success"]),
                  "failed": len([r for r in results if r["status"] != "success"]),
                  "clips": results
              }
              
              with open(PROCESSING_LOG, "w") as f:
                  json.dump(summary, f, indent=2, ensure_ascii=False)
              
              logger.info("")
              logger.info("=" * 50)
              logger.info("üìä RESUMO")
              logger.info(f"   ‚úÖ Sucesso: {summary['success']}/{summary['total']}")
              logger.info(f"   ‚ùå Falhas: {summary['failed']}/{summary['total']}")
              logger.info("=" * 50)


          if __name__ == "__main__":
              main()
          SCRIPT_EOF
          
          chmod +x scripts/clip_creator.py

      - name: üé¨ Processar Clipes
        env:
          VOD_LINK: ${{ github.event.inputs.vod_link }}
        run: |
          python scripts/clip_creator.py "$VOD_LINK"

      - name: üìä Resumo
        if: always()
        run: |
          echo "## üìä Resumo" >> $GITHUB_STEP_SUMMARY
          if [ -f "processing_log.json" ]; then
            echo '```json' >> $GITHUB_STEP_SUMMARY
            cat processing_log.json >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

      - name: üì§ Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: logs
          path: |
            *.log
            processing_log.json
          retention-days: 7
