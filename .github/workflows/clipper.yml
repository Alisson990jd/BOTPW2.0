# .github/workflows/youtube-clipper.yml
name: YouTube Clipper - VOD to Clips

on:
  workflow_dispatch:
    inputs:
      vod_link:
        description: 'Link do VOD da Twitch'
        required: true
        type: string
      senha:
        description: 'Senha para executar'
        required: true
        type: string

jobs:
  validate-and-process:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    
    steps:
      - name: üîê Validar Senha
        run: |
          if [ "${{ github.event.inputs.senha }}" != "${{ secrets.SENHA }}" ]; then
            echo "‚ùå Senha incorreta!"
            exit 1
          fi
          echo "‚úÖ Senha validada com sucesso!"

      - name: üì• Checkout do reposit√≥rio
        uses: actions/checkout@v4

      - name: üêç Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: üì¶ Instalar depend√™ncias do sistema
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq
          
      - name: üé≠ Instalar Playwright
        run: |
          pip install playwright
          playwright install chromium
          playwright install-deps chromium

      - name: üì¶ Instalar depend√™ncias Python
        run: |
          pip install --upgrade pip
          pip install requests google-auth google-auth-oauthlib google-api-python-client
          pip install yt-dlp httpx aiohttp pillow
          pip install playwright

      - name: üì• Baixar arquivos do reposit√≥rio externo
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          echo "üì• Baixando analise_resultado.json..."
          curl -H "Authorization: token $GH_PAT" \
               -H "Accept: application/vnd.github.v3.raw" \
               -o analise_resultado.json \
               "https://api.github.com/repos/Alisson990jd/apiss/contents/analise_resultado.json"
          
          echo "üì• Baixando gmail_token.pkl..."
          curl -H "Authorization: token $GH_PAT" \
               -H "Accept: application/vnd.github.v3.raw" \
               -o gmail_token.pkl \
               "https://api.github.com/repos/Alisson990jd/apiss/contents/gmail_token.pkl"
          
          echo "üì• Baixando arquivos da pasta analisar..."
          mkdir -p analisar
          
          # Listar e baixar todos os arquivos (JSON e PKL)
          FILES=$(curl -s -H "Authorization: token $GH_PAT" \
                       -H "Accept: application/vnd.github.v3+json" \
                       "https://api.github.com/repos/Alisson990jd/apiss/contents/analisar" | \
                  jq -r '.[].name')
          
          for file in $FILES; do
            echo "  üìÑ Baixando $file..."
            curl -H "Authorization: token $GH_PAT" \
                 -H "Accept: application/vnd.github.v3.raw" \
                 -o "analisar/$file" \
                 "https://api.github.com/repos/Alisson990jd/apiss/contents/analisar/$file"
          done
          
          echo "‚úÖ Todos os arquivos baixados!"
          ls -la
          ls -la analisar/

      - name: üé¨ Processar Clipes e Fazer Upload
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
          VOD_URL: ${{ github.event.inputs.vod_link }}
        run: |
          python3 << 'PYTHON_SCRIPT'
          import os
          import sys
          import json
          import time
          import pickle
          import base64
          import subprocess
          import requests
          import re
          import shutil
          from datetime import datetime, timezone
          from pathlib import Path
          from google.auth.transport.requests import Request
          from googleapiclient.discovery import build
          from googleapiclient.http import MediaFileUpload
          from playwright.sync_api import sync_playwright

          # ==================== CONFIGURA√á√ïES ====================
          VOD_URL = os.environ.get('VOD_URL')
          WORK_DIR = "temp_work"
          EMAIL_ADDRESS = "expulsion-flip-elk@duck.com"
          GMAIL_TOKEN = "gmail_token.pkl"
          CHATGPT_URL = "https://chatgpt.com/"
          HEADLESS = True
          TIMEOUT = 120000

          # Criar diret√≥rio de trabalho
          os.makedirs(WORK_DIR, exist_ok=True)

          # ==================== FUN√á√ïES AUXILIARES ====================
          def time_to_seconds(time_str):
              """Converte HH:MM:SS para segundos"""
              parts = time_str.split(':')
              if len(parts) == 3:
                  h, m, s = parts
                  # Trata caso tenha decimais nos segundos
                  h = int(h)
                  m = int(m)
                  s = float(s)
                  return h * 3600 + m * 60 + s
              elif len(parts) == 2:
                  m, s = parts
                  m = int(m)
                  s = float(s)
                  return m * 60 + s
              return float(parts[0])

          def seconds_to_time(seconds):
              """Converte segundos para HH:MM:SS"""
              h = int(seconds // 3600)
              m = int((seconds % 3600) // 60)
              s = int(seconds % 60)
              return f"{h:02d}:{m:02d}:{s:02d}"

          def download_clip_segment(vod_url, start_time, end_time, output_path):
              """Baixa apenas o segmento espec√≠fico do VOD usando yt-dlp"""
              start_sec = time_to_seconds(start_time)
              end_sec = time_to_seconds(end_time)
              
              # Adiciona margem de seguran√ßa (5 segundos antes e depois)
              start_sec = max(0, start_sec - 5)
              end_sec = end_sec + 5
              
              # Formato para yt-dlp: *START-END
              section = f"*{seconds_to_time(start_sec)}-{seconds_to_time(end_sec)}"
              
              print(f"   üì• Baixando segmento: {start_time} -> {end_time}")
              print(f"   üì• Se√ß√£o com margem: {seconds_to_time(start_sec)} -> {seconds_to_time(end_sec)}")
              
              cmd = [
                  'yt-dlp',
                  '-f', 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',
                  '--merge-output-format', 'mp4',
                  '--download-sections', section,
                  '--force-keyframes-at-cuts',
                  '-o', output_path,
                  '--no-playlist',
                  '--retries', '10',
                  '--fragment-retries', '10',
                  vod_url
              ]
              
              print(f"   üîß Comando: {' '.join(cmd)}")
              
              result = subprocess.run(cmd, capture_output=True, text=True)
              
              if result.returncode != 0:
                  print(f"   ‚ö†Ô∏è Stderr: {result.stderr}")
                  # Tenta m√©todo alternativo com ffmpeg direto
                  return download_with_ffmpeg(vod_url, start_sec, end_sec, output_path)
              
              if os.path.exists(output_path):
                  size_mb = os.path.getsize(output_path) / (1024 * 1024)
                  print(f"   ‚úÖ Segmento baixado: {size_mb:.2f} MB")
                  return True
              
              return False

          def download_with_ffmpeg(vod_url, start_sec, end_sec, output_path):
              """M√©todo alternativo: usa ffmpeg para baixar diretamente"""
              print("   üîÑ Tentando m√©todo alternativo com ffmpeg...")
              
              # Primeiro pega a URL direta do stream
              cmd_url = [
                  'yt-dlp',
                  '-f', 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',
                  '-g',
                  vod_url
              ]
              
              result = subprocess.run(cmd_url, capture_output=True, text=True)
              
              if result.returncode != 0:
                  print(f"   ‚ùå Erro ao obter URL: {result.stderr}")
                  return False
              
              urls = result.stdout.strip().split('\n')
              
              if len(urls) >= 2:
                  # Video e audio separados
                  video_url = urls[0]
                  audio_url = urls[1]
                  
                  duration = end_sec - start_sec
                  
                  cmd = [
                      'ffmpeg', '-y',
                      '-ss', str(start_sec),
                      '-i', video_url,
                      '-ss', str(start_sec),
                      '-i', audio_url,
                      '-t', str(duration),
                      '-c:v', 'copy',
                      '-c:a', 'aac',
                      '-map', '0:v:0',
                      '-map', '1:a:0',
                      '-movflags', '+faststart',
                      output_path
                  ]
              else:
                  # URL √∫nica
                  stream_url = urls[0]
                  duration = end_sec - start_sec
                  
                  cmd = [
                      'ffmpeg', '-y',
                      '-ss', str(start_sec),
                      '-i', stream_url,
                      '-t', str(duration),
                      '-c:v', 'copy',
                      '-c:a', 'aac',
                      '-movflags', '+faststart',
                      output_path
                  ]
              
              result = subprocess.run(cmd, capture_output=True, text=True)
              
              if result.returncode != 0:
                  print(f"   ‚ùå Erro ffmpeg: {result.stderr[:500]}")
                  return False
              
              if os.path.exists(output_path):
                  size_mb = os.path.getsize(output_path) / (1024 * 1024)
                  print(f"   ‚úÖ Segmento baixado via ffmpeg: {size_mb:.2f} MB")
                  return True
              
              return False

          def extract_screenshot(video_path, timestamp, clip_start, output_path):
              """Extrai uma screenshot do clipe baixado"""
              # Calcula o timestamp relativo ao clipe
              clip_start_sec = time_to_seconds(clip_start)
              thumb_sec = time_to_seconds(timestamp)
              relative_sec = thumb_sec - clip_start_sec + 5  # +5 pela margem adicionada
              
              # Garante que n√£o seja negativo
              relative_sec = max(0, relative_sec)
              
              cmd = [
                  'ffmpeg', '-y',
                  '-ss', str(relative_sec),
                  '-i', video_path,
                  '-vframes', '1',
                  '-q:v', '2',
                  output_path
              ]
              
              print(f"   üì∏ Extraindo screenshot no segundo {relative_sec:.1f}")
              result = subprocess.run(cmd, capture_output=True, text=True)
              
              if result.returncode != 0:
                  print(f"   ‚ö†Ô∏è Erro screenshot: {result.stderr[:200]}")
                  return False
              
              if os.path.exists(output_path):
                  print(f"   ‚úÖ Screenshot extra√≠da!")
                  return True
              return False

          def trim_clip(input_path, output_path, start_time, end_time):
              """Corta o clipe para o tempo exato (remove margens)"""
              # O clipe baixado tem 5s de margem no in√≠cio
              # Vamos cortar para o tempo exato
              
              start_sec = 5  # Margem que adicionamos
              duration = time_to_seconds(end_time) - time_to_seconds(start_time)
              
              cmd = [
                  'ffmpeg', '-y',
                  '-ss', str(start_sec),
                  '-i', input_path,
                  '-t', str(duration),
                  '-c:v', 'libx264',
                  '-preset', 'fast',
                  '-crf', '18',
                  '-c:a', 'aac',
                  '-b:a', '192k',
                  '-movflags', '+faststart',
                  output_path
              ]
              
              print(f"   ‚úÇÔ∏è Cortando para dura√ß√£o exata: {duration}s")
              result = subprocess.run(cmd, capture_output=True, text=True)
              
              if result.returncode != 0:
                  print(f"   ‚ö†Ô∏è Erro ao cortar: {result.stderr[:200]}")
                  # Usa o arquivo original se falhar
                  shutil.copy(input_path, output_path)
              
              return os.path.exists(output_path)

          def cleanup_files(*paths):
              """Remove arquivos tempor√°rios"""
              for path in paths:
                  if path and os.path.exists(path):
                      try:
                          os.remove(path)
                          print(f"   üóëÔ∏è Removido: {os.path.basename(path)}")
                      except Exception as e:
                          print(f"   ‚ö†Ô∏è Erro ao remover {path}: {e}")

          def get_disk_usage():
              """Retorna uso de disco em GB"""
              total, used, free = shutil.disk_usage("/")
              return {
                  'total': total / (1024**3),
                  'used': used / (1024**3),
                  'free': free / (1024**3)
              }

          # ==================== GMAIL API ====================
          def get_gmail_service():
              """Carrega credenciais do Gmail"""
              if not os.path.exists(GMAIL_TOKEN):
                  raise FileNotFoundError(f"‚ùå Arquivo '{GMAIL_TOKEN}' n√£o encontrado!")
              
              with open(GMAIL_TOKEN, 'rb') as token:
                  creds = pickle.load(token)
              
              if creds and creds.expired and creds.refresh_token:
                  print("üîÑ Renovando token do Gmail...")
                  creds.refresh(Request())
                  with open(GMAIL_TOKEN, 'wb') as token:
                      pickle.dump(creds, token)
              
              return build('gmail', 'v1', credentials=creds)

          def get_chatgpt_code(service, max_attempts=60, interval=3):
              """Aguarda e extrai o c√≥digo de verifica√ß√£o do ChatGPT"""
              print("   üìß Aguardando c√≥digo do ChatGPT...")
              
              start_time = datetime.now(timezone.utc)
              
              for attempt in range(max_attempts):
                  print(f"      Tentativa {attempt + 1}/{max_attempts}...", end="\r")
                  
                  query = "from:noreply@tm.openai.com subject:Your ChatGPT code is"
                  results = service.users().messages().list(
                      userId='me',
                      q=query,
                      maxResults=5
                  ).execute()
                  
                  messages = results.get('messages', [])
                  
                  for msg in messages:
                      message = service.users().messages().get(
                          userId='me',
                          id=msg['id'],
                          format='full'
                      ).execute()
                      
                      internal_date = int(message.get('internalDate', 0)) / 1000
                      email_time = datetime.fromtimestamp(internal_date, tz=timezone.utc)
                      
                      if email_time < start_time:
                          continue
                      
                      headers = message['payload'].get('headers', [])
                      subject = next(
                          (h['value'] for h in headers if h['name'].lower() == 'subject'),
                          ''
                      )
                      
                      match = re.search(r'Your ChatGPT code is (\d{6})', subject)
                      if match:
                          code = match.group(1)
                          print(f"\n   ‚úÖ C√≥digo encontrado: {code}")
                          return code
                  
                  time.sleep(interval)
              
              raise TimeoutError("‚ùå Tempo esgotado aguardando o email com o c√≥digo.")

          # ==================== YOUTUBE API ====================
          def get_youtube_service(pkl_path):
              """Carrega credenciais do YouTube de um arquivo pkl"""
              with open(pkl_path, 'rb') as f:
                  creds = pickle.load(f)
              
              if creds and creds.expired and creds.refresh_token:
                  print("   üîÑ Renovando token do YouTube...")
                  creds.refresh(Request())
                  with open(pkl_path, 'wb') as f:
                      pickle.dump(creds, f)
              
              return build('youtube', 'v3', credentials=creds)

          def upload_to_youtube(youtube, video_path, title, description, tags, thumbnail_path=None):
              """Faz upload do v√≠deo para o YouTube como privado"""
              body = {
                  'snippet': {
                      'title': title[:100],
                      'description': description[:5000],
                      'tags': tags[:500] if tags else [],
                      'categoryId': '22'
                  },
                  'status': {
                      'privacyStatus': 'private',
                      'selfDeclaredMadeForKids': False
                  }
              }
              
              media = MediaFileUpload(
                  video_path,
                  mimetype='video/mp4',
                  resumable=True,
                  chunksize=1024*1024*5  # 5MB chunks
              )
              
              print(f"   üì§ Iniciando upload...")
              
              request = youtube.videos().insert(
                  part=','.join(body.keys()),
                  body=body,
                  media_body=media
              )
              
              response = None
              last_progress = 0
              while response is None:
                  status, response = request.next_chunk()
                  if status:
                      progress = int(status.progress() * 100)
                      if progress >= last_progress + 10:
                          print(f"   üìä Upload: {progress}%")
                          last_progress = progress
              
              video_id = response['id']
              print(f"   ‚úÖ Upload conclu√≠do! ID: {video_id}")
              
              # Upload da thumbnail
              if thumbnail_path and os.path.exists(thumbnail_path):
                  try:
                      print(f"   üñºÔ∏è Enviando thumbnail...")
                      youtube.thumbnails().set(
                          videoId=video_id,
                          media_body=MediaFileUpload(thumbnail_path)
                      ).execute()
                      print(f"   ‚úÖ Thumbnail enviada!")
                  except Exception as e:
                      print(f"   ‚ö†Ô∏è Erro ao enviar thumbnail: {e}")
              
              return video_id

          # ==================== CHATGPT THUMBNAIL GENERATOR ====================
          def generate_thumbnail(screenshot_path, clip_info, gmail_service, browser_context=None):
              """Gera thumbnail usando ChatGPT"""
              print(f"\n   üé® Gerando thumbnail com ChatGPT...")
              
              clip_json = json.dumps(clip_info, indent=2, ensure_ascii=False)
              prompt = f"transforme em uma thumbnail para youtube(1280x720), esse √© o clipe:\n{clip_json}"
              
              thumbnail_path = os.path.join(WORK_DIR, f"thumb_{clip_info['clip_id']}.png")
              
              with sync_playwright() as p:
                  browser = p.chromium.launch(
                      headless=HEADLESS,
                      args=[
                          '--disable-blink-features=AutomationControlled',
                          '--no-sandbox',
                          '--disable-dev-shm-usage',
                          '--disable-gpu',
                      ]
                  )
                  
                  context = browser.new_context(
                      viewport={'width': 1920, 'height': 1080},
                      accept_downloads=True,
                      user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
                      locale='en-US',
                  )
                  
                  page = context.new_page()
                  page.set_default_timeout(TIMEOUT)
                  
                  try:
                      # Acessa ChatGPT
                      print("      üîó Acessando ChatGPT...")
                      page.goto(CHATGPT_URL, wait_until='networkidle', timeout=60000)
                      time.sleep(3)
                      
                      # Verifica login
                      login_needed = False
                      try:
                          login_button = page.locator('[data-testid="login-button"]')
                          if login_button.is_visible(timeout=5000):
                              login_needed = True
                      except:
                          pass
                      
                      if login_needed:
                          print("      üîê Fazendo login...")
                          login_button = page.locator('[data-testid="login-button"]')
                          login_button.click()
                          
                          email_input = page.locator('input[name="email"]')
                          email_input.wait_for(state='visible', timeout=15000)
                          email_input.fill(EMAIL_ADDRESS)
                          
                          continue_button = page.locator('button[type="submit"]:has-text("Continue")')
                          continue_button.click()
                          
                          code = get_chatgpt_code(gmail_service)
                          
                          code_input = page.locator('input[name="code"]')
                          code_input.wait_for(state='visible', timeout=15000)
                          code_input.fill(code)
                          
                          validate_button = page.locator('button[name="intent"][value="validate"]')
                          validate_button.click()
                          
                          page.wait_for_url("**/", timeout=30000)
                          time.sleep(5)
                          print("      ‚úÖ Login realizado!")
                      
                      # Criar imagem
                      print("      üìå Selecionando 'Create image'...")
                      page.goto(CHATGPT_URL, wait_until='domcontentloaded')
                      time.sleep(3)
                      
                      plus_btn = page.locator('[data-testid="composer-plus-btn"]')
                      plus_btn.wait_for(state="visible", timeout=15000)
                      plus_btn.click()
                      time.sleep(1)
                      
                      create_image_btn = page.locator('div[role="menuitemradio"]:has-text("Create image")')
                      create_image_btn.wait_for(state="visible", timeout=5000)
                      create_image_btn.click()
                      time.sleep(2)
                      
                      # Adicionar imagem
                      print("      üìå Adicionando screenshot...")
                      try:
                          file_input = page.locator('input[type="file"]').first
                          file_input.set_input_files(screenshot_path)
                          print("      ‚úÖ Imagem adicionada!")
                          time.sleep(2)
                      except Exception as e:
                          print(f"      ‚ö†Ô∏è M√©todo alternativo: {e}")
                          with open(screenshot_path, 'rb') as f:
                              file_content = base64.b64encode(f.read()).decode()
                          
                          file_name = os.path.basename(screenshot_path)
                          page.evaluate(f'''
                              () => {{
                                  const base64 = "{file_content}";
                                  const binaryString = atob(base64);
                                  const bytes = new Uint8Array(binaryString.length);
                                  for (let i = 0; i < binaryString.length; i++) {{
                                      bytes[i] = binaryString.charCodeAt(i);
                                  }}
                                  const blob = new Blob([bytes], {{ type: 'image/png' }});
                                  const file = new File([blob], '{file_name}', {{ type: 'image/png' }});
                                  
                                  const target = document.querySelector('#prompt-textarea') || document.querySelector('[contenteditable="true"]');
                                  if (!target) return false;
                                  
                                  const dataTransfer = new DataTransfer();
                                  dataTransfer.items.add(file);
                                  
                                  ['dragenter', 'dragover', 'drop'].forEach(eventType => {{
                                      const event = new DragEvent(eventType, {{
                                          bubbles: true,
                                          cancelable: true,
                                          dataTransfer: dataTransfer
                                      }});
                                      target.dispatchEvent(event);
                                  }});
                                  
                                  return true;
                              }}
                          ''')
                          time.sleep(3)
                      
                      # Inserir prompt
                      print("      üìå Inserindo prompt...")
                      prompt_escaped = prompt.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace("'", "\\'")
                      
                      textarea = page.locator('#prompt-textarea')
                      textarea.wait_for(state="visible", timeout=5000)
                      textarea.click()
                      time.sleep(0.5)
                      
                      page.evaluate(f'''
                          () => {{
                              const textarea = document.querySelector('#prompt-textarea');
                              if (!textarea) return;
                              
                              const p = textarea.querySelector('p');
                              if (p) {{
                                  p.innerHTML = "{prompt_escaped}";
                              }} else {{
                                  textarea.innerHTML = "<p>{prompt_escaped}</p>";
                              }}
                              
                              textarea.dispatchEvent(new Event('input', {{ bubbles: true }}));
                          }}
                      ''')
                      time.sleep(1)
                      
                      # Enviar
                      print("      üìå Enviando...")
                      send_btn = page.locator('#composer-submit-button')
                      send_btn.wait_for(state="visible", timeout=5000)
                      send_btn.click()
                      
                      # Aguardar gera√ß√£o (4 minutos)
                      print("      ‚è≥ Aguardando gera√ß√£o (4 min)...")
                      for remaining in range(240, 0, -30):
                          print(f"         Restam {remaining}s...", end='\r')
                          time.sleep(30)
                      print("      ‚úÖ Tempo de espera conclu√≠do!")
                      
                      # Baixar imagem
                      print("      üìå Baixando thumbnail...")
                      time.sleep(5)
                      
                      try:
                          image_containers = page.locator('div[class*="group/imagegen-image"]').all()
                          
                          if len(image_containers) > 0:
                              last_container = image_containers[-1]
                              last_container.hover()
                              time.sleep(1)
                              
                              download_btn = last_container.locator('button[aria-label="Download this image"]')
                              download_btn.wait_for(state="visible", timeout=10000)
                              
                              with page.expect_download(timeout=60000) as download_info:
                                  download_btn.click()
                              
                              download = download_info.value
                              download.save_as(thumbnail_path)
                              print(f"      ‚úÖ Thumbnail salva!")
                          else:
                              # Tenta URL direta
                              img_url = page.evaluate('''
                                  () => {
                                      const containers = document.querySelectorAll('div[class*="group/imagegen-image"]');
                                      if (containers.length > 0) {
                                          const lastContainer = containers[containers.length - 1];
                                          const img = lastContainer.querySelector('img[alt="Generated image"]');
                                          return img ? img.src : null;
                                      }
                                      return null;
                                  }
                              ''')
                              
                              if img_url:
                                  cookies = context.cookies()
                                  cookie_str = "; ".join([f"{c['name']}={c['value']}" for c in cookies])
                                  
                                  headers = {
                                      "Cookie": cookie_str,
                                      "User-Agent": page.evaluate("navigator.userAgent"),
                                      "Referer": "https://chatgpt.com/"
                                  }
                                  
                                  response = requests.get(img_url, headers=headers)
                                  if response.status_code == 200:
                                      with open(thumbnail_path, 'wb') as f:
                                          f.write(response.content)
                                      print(f"      ‚úÖ Thumbnail baixada via URL!")
                                  else:
                                      thumbnail_path = None
                              else:
                                  thumbnail_path = None
                                  
                      except Exception as e:
                          print(f"      ‚ùå Erro: {e}")
                          thumbnail_path = None
                      
                  except Exception as e:
                      print(f"      ‚ùå Erro na gera√ß√£o: {e}")
                      try:
                          page.screenshot(path=f'error_{clip_info["clip_id"]}.png')
                      except:
                          pass
                      thumbnail_path = None
                  
                  finally:
                      browser.close()
              
              return thumbnail_path if thumbnail_path and os.path.exists(thumbnail_path) else None

          # ==================== MAIN ====================
          def main():
              print("=" * 70)
              print("   YOUTUBE CLIPPER - DOWNLOAD OTIMIZADO POR SEGMENTO")
              print("=" * 70)
              
              disk = get_disk_usage()
              print(f"\nüíæ Disco: {disk['free']:.1f} GB livres de {disk['total']:.1f} GB")
              
              # Carregar an√°lise
              print("\nüìÑ Carregando analise_resultado.json...")
              with open('analise_resultado.json', 'r', encoding='utf-8') as f:
                  analise = json.load(f)
              
              # Filtrar apenas clipes do YouTube
              youtube_clips = [c for c in analise.get('clips', []) if c.get('platform') == 'youtube']
              print(f"   üìπ {len(youtube_clips)} clipes do YouTube encontrados")
              
              if not youtube_clips:
                  print("‚ùå Nenhum clipe do YouTube encontrado!")
                  return
              
              # Carregar credenciais do YouTube
              print("\nüîë Carregando credenciais...")
              youtube_credentials = []
              
              for file in os.listdir('analisar'):
                  if file.endswith('.json'):
                      filepath = os.path.join('analisar', file)
                      try:
                          with open(filepath, 'r', encoding='utf-8') as f:
                              cred_data = json.load(f)
                              if 'pkl_file' in cred_data:
                                  youtube_credentials.append(cred_data)
                      except:
                          continue
              
              print(f"   üîê {len(youtube_credentials)} credenciais encontradas")
              
              if not youtube_credentials:
                  print("‚ùå Nenhuma credencial do YouTube encontrada!")
                  return
              
              # Inicializar servi√ßos
              print("\nüìß Conectando ao Gmail...")
              try:
                  gmail_service = get_gmail_service()
                  print("   ‚úÖ Gmail conectado!")
              except Exception as e:
                  print(f"   ‚ö†Ô∏è Gmail n√£o dispon√≠vel: {e}")
                  gmail_service = None
              
              # Usar primeira credencial
              cred = youtube_credentials[0]
              pkl_path = os.path.join('analisar', cred['pkl_file'])
              
              print(f"\nüé¨ Conectando ao YouTube: {cred['channel_info']['title']}...")
              youtube_service = get_youtube_service(pkl_path)
              print("   ‚úÖ YouTube conectado!")
              
              # Processar cada clipe
              print("\n" + "=" * 70)
              print("   PROCESSANDO CLIPES (UM DE CADA VEZ)")
              print("=" * 70)
              
              successful = 0
              failed = 0
              
              for i, clip in enumerate(youtube_clips, 1):
                  print(f"\n{'‚ïê' * 70}")
                  print(f"üìπ CLIPE {i}/{len(youtube_clips)}")
                  print(f"   üìù T√≠tulo: {clip['title']}")
                  print(f"   ‚è±Ô∏è  Tempo: {clip['start_time']} -> {clip['end_time']}")
                  print(f"   ‚è±Ô∏è  Dura√ß√£o: {clip['duration_seconds']}s")
                  print(f"{'‚ïê' * 70}")
                  
                  # Verificar espa√ßo em disco
                  disk = get_disk_usage()
                  print(f"\n   üíæ Espa√ßo livre: {disk['free']:.1f} GB")
                  
                  if disk['free'] < 1:
                      print("   ‚ö†Ô∏è Espa√ßo em disco baixo! Limpando...")
                      # Limpa pasta de trabalho
                      for f in os.listdir(WORK_DIR):
                          os.remove(os.path.join(WORK_DIR, f))
                  
                  # Paths dos arquivos
                  raw_clip_path = os.path.join(WORK_DIR, f"raw_{clip['clip_id']}.mp4")
                  final_clip_path = os.path.join(WORK_DIR, f"final_{clip['clip_id']}.mp4")
                  screenshot_path = os.path.join(WORK_DIR, f"screenshot_{clip['clip_id']}.png")
                  thumbnail_path = os.path.join(WORK_DIR, f"thumb_{clip['clip_id']}.png")
                  
                  try:
                      # ETAPA 1: Baixar segmento do VOD
                      print("\n   üì• ETAPA 1: Baixando segmento do VOD...")
                      
                      if not download_clip_segment(VOD_URL, clip['start_time'], clip['end_time'], raw_clip_path):
                          print("   ‚ùå Falha ao baixar segmento!")
                          failed += 1
                          cleanup_files(raw_clip_path)
                          continue
                      
                      # ETAPA 2: Cortar para tempo exato
                      print("\n   ‚úÇÔ∏è ETAPA 2: Cortando para tempo exato...")
                      if not trim_clip(raw_clip_path, final_clip_path, clip['start_time'], clip['end_time']):
                          print("   ‚ö†Ô∏è Usando clipe sem corte")
                          final_clip_path = raw_clip_path
                      
                      # ETAPA 3: Extrair screenshot
                      print("\n   üì∏ ETAPA 3: Extraindo screenshot...")
                      thumbnail_timestamp = clip.get('thumbnail_timestamp', clip['start_time'])
                      
                      if not extract_screenshot(raw_clip_path, thumbnail_timestamp, clip['start_time'], screenshot_path):
                          print("   ‚ö†Ô∏è Continuando sem screenshot")
                          screenshot_path = None
                      
                      # ETAPA 4: Gerar thumbnail (opcional)
                      generated_thumb = None
                      if screenshot_path and gmail_service:
                          print("\n   üé® ETAPA 4: Gerando thumbnail...")
                          try:
                              generated_thumb = generate_thumbnail(screenshot_path, clip, gmail_service)
                          except Exception as e:
                              print(f"   ‚ö†Ô∏è Erro na thumbnail: {e}")
                      else:
                          print("\n   ‚è≠Ô∏è ETAPA 4: Pulando gera√ß√£o de thumbnail")
                      
                      # ETAPA 5: Upload para YouTube
                      print("\n   üì§ ETAPA 5: Upload para YouTube...")
                      
                      video_id = upload_to_youtube(
                          youtube_service,
                          final_clip_path,
                          clip['title'],
                          clip.get('recommended_description', ''),
                          clip.get('tags', []),
                          generated_thumb
                      )
                      
                      print(f"\n   üéâ SUCESSO! https://youtube.com/watch?v={video_id}")
                      successful += 1
                      
                  except Exception as e:
                      print(f"\n   ‚ùå ERRO: {e}")
                      import traceback
                      traceback.print_exc()
                      failed += 1
                  
                  finally:
                      # ETAPA 6: Limpeza
                      print("\n   üóëÔ∏è ETAPA 6: Limpando arquivos tempor√°rios...")
                      cleanup_files(raw_clip_path, final_clip_path, screenshot_path, thumbnail_path)
                      
                      # Verifica espa√ßo ap√≥s limpeza
                      disk = get_disk_usage()
                      print(f"   üíæ Espa√ßo ap√≥s limpeza: {disk['free']:.1f} GB")
                  
                  # Pausa entre clipes
                  if i < len(youtube_clips):
                      print("\n   ‚è≥ Aguardando 5 segundos antes do pr√≥ximo...")
                      time.sleep(5)
              
              # Resumo final
              print("\n" + "=" * 70)
              print("   üìä RESUMO FINAL")
              print("=" * 70)
              print(f"   ‚úÖ Clipes postados com sucesso: {successful}")
              print(f"   ‚ùå Clipes com falha: {failed}")
              print(f"   üìπ Total processado: {successful + failed}/{len(youtube_clips)}")
              
              disk = get_disk_usage()
              print(f"\n   üíæ Espa√ßo final: {disk['free']:.1f} GB livres")
              print("=" * 70)

          if __name__ == "__main__":
              try:
                  main()
              except KeyboardInterrupt:
                  print("\n‚ö†Ô∏è Opera√ß√£o cancelada!")
              except Exception as e:
                  print(f"\n‚ùå Erro fatal: {e}")
                  import traceback
                  traceback.print_exc()
                  sys.exit(1)
          PYTHON_SCRIPT

      - name: üìä Exibir resultados
        if: always()
        run: |
          echo "=== Status do disco ==="
          df -h
          echo ""
          echo "=== Arquivos tempor√°rios ==="
          ls -la temp_work/ 2>/dev/null || echo "Pasta vazia ou removida"
          echo "=== Fim ==="
