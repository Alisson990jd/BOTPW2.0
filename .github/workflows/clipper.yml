name: üé¨ Criar Clipes para YouTube

on:
  workflow_dispatch:
    inputs:
      vod_url:
        description: 'URL do VOD da Twitch'
        required: true
        type: string
      senha:
        description: 'Senha de Execu√ß√£o'
        required: true
        type: string

jobs:
  validate-and-process:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    
    steps:
      - name: üîê Validar Senha
        run: |
          if [ "${{ github.event.inputs.senha }}" != "${{ secrets.SENHA }}" ]; then
            echo "‚ùå Senha inv√°lida!"
            exit 1
          fi
          echo "‚úÖ Senha validada com sucesso!"

      - name: üì• Checkout do Reposit√≥rio
        uses: actions/checkout@v4

      - name: üêç Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: üì¶ Instalar Depend√™ncias do Sistema
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          
      - name: üì¶ Instalar Depend√™ncias Python
        run: |
          pip install --upgrade pip
          pip install yt-dlp google-api-python-client google-auth-httplib2 google-auth-oauthlib
          pip install playwright requests pillow
          playwright install chromium
          playwright install-deps

      - name: üì• Baixar Arquivos do Reposit√≥rio Externo
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          # Criar diret√≥rios
          mkdir -p config_data
          mkdir -p youtube_accounts
          
          # Baixar analise_resultado.json
          echo "üì• Baixando analise_resultado.json..."
          curl -H "Authorization: token $GH_TOKEN" \
               -H "Accept: application/vnd.github.v3.raw" \
               -o config_data/analise_resultado.json \
               https://raw.githubusercontent.com/Alisson990jd/apiss/main/analise_resultado.json
          
          # Baixar gmail_token.pkl
          echo "üì• Baixando gmail_token.pkl..."
          curl -H "Authorization: token $GH_TOKEN" \
               -H "Accept: application/vnd.github.v3.raw" \
               -o config_data/gmail_token.pkl \
               https://raw.githubusercontent.com/Alisson990jd/apiss/main/gmail_token.pkl
          
          # Listar arquivos JSON da pasta analisar
          echo "üì• Baixando arquivos de autentica√ß√£o do YouTube..."
          
          # Usar API do GitHub para listar arquivos
          curl -H "Authorization: token $GH_TOKEN" \
               -H "Accept: application/vnd.github.v3+json" \
               https://api.github.com/repos/Alisson990jd/apiss/contents/analisar > files_list.json
          
          # Baixar cada arquivo JSON
          cat files_list.json | grep -o '"download_url": "[^"]*"' | sed 's/"download_url": "\(.*\)"/\1/' | while read url; do
            if [[ $url == *.json ]]; then
              filename=$(basename $url)
              echo "  üìÑ Baixando $filename..."
              curl -H "Authorization: token $GH_TOKEN" -o "youtube_accounts/$filename" "$url"
            fi
          done
          
          rm files_list.json
          
          echo "‚úÖ Todos os arquivos baixados!"
          echo "üìä Arquivos de contas YouTube: $(ls -1 youtube_accounts/*.json | wc -l)"

      - name: üé¨ Criar Scripts de Processamento
        run: |
          cat > process_clips.py << 'PYTHON_SCRIPT_EOF'
          import os
          import json
          import subprocess
          import sys
          from pathlib import Path

          VOD_URL = "${{ github.event.inputs.vod_url }}"
          ANALISE_FILE = "config_data/analise_resultado.json"
          TEMP_DIR = Path("temp_processing")
          TEMP_DIR.mkdir(exist_ok=True)

          def load_clips():
              """Carrega e filtra clipes do YouTube"""
              print("üìÇ Carregando arquivo de an√°lise...")
              with open(ANALISE_FILE, 'r', encoding='utf-8') as f:
                  data = json.load(f)
              
              youtube_clips = [c for c in data.get('clips', []) if c.get('platform') == 'youtube']
              print(f"‚úÖ {len(youtube_clips)} clipes do YouTube encontrados")
              return youtube_clips

          def download_clip_segment(vod_url, start_time, end_time, output_file):
              """Baixa apenas o segmento espec√≠fico do VOD"""
              print(f"üì• Baixando segmento: {start_time} -> {end_time}")
              
              # Converter tempo para segundos
              def time_to_seconds(time_str):
                  parts = time_str.split(':')
                  return int(parts[0]) * 3600 + int(parts[1]) * 60 + int(parts[2])
              
              start_sec = time_to_seconds(start_time)
              end_sec = time_to_seconds(end_time)
              duration = end_sec - start_sec
              
              cmd = [
                  'yt-dlp',
                  '--force-keyframes-at-cuts',
                  '--download-sections', f'*{start_time}-{end_time}',
                  '-f', 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',
                  '--merge-output-format', 'mp4',
                  '-o', str(output_file),
                  '--no-playlist',
                  '--concurrent-fragments', '8',
                  vod_url
              ]
              
              try:
                  result = subprocess.run(cmd, check=True, capture_output=True, text=True)
                  print(f"‚úÖ Download conclu√≠do: {output_file}")
                  return True
              except subprocess.CalledProcessError as e:
                  print(f"‚ùå Erro no download: {e}")
                  print(f"STDOUT: {e.stdout}")
                  print(f"STDERR: {e.stderr}")
                  return False

          def capture_thumbnail_frame(vod_url, timestamp, output_file):
              """Captura frame do v√≠deo no timestamp especificado"""
              print(f"üì∏ Capturando frame em {timestamp}...")
              
              cmd = [
                  'ffmpeg',
                  '-ss', timestamp,
                  '-i', vod_url,
                  '-vframes', '1',
                  '-q:v', '2',
                  '-y',
                  str(output_file)
              ]
              
              try:
                  subprocess.run(cmd, check=True, capture_output=True)
                  print(f"‚úÖ Frame capturado: {output_file}")
                  return True
              except subprocess.CalledProcessError as e:
                  print(f"‚ùå Erro ao capturar frame: {e}")
                  return False

          def main():
              clips = load_clips()
              
              if not clips:
                  print("‚ö†Ô∏è Nenhum clipe do YouTube para processar")
                  return
              
              # Salvar informa√ß√µes dos clipes para processamento posterior
              clips_info = []
              
              for idx, clip in enumerate(clips, 1):
                  print(f"\n{'='*60}")
                  print(f"üìπ PROCESSANDO CLIPE {idx}/{len(clips)}")
                  print(f"{'='*60}")
                  print(f"üé¨ T√≠tulo: {clip['title']}")
                  print(f"‚è±Ô∏è  Dura√ß√£o: {clip['duration_seconds']}s")
                  print(f"üìç Tempo: {clip['start_time']} -> {clip['end_time']}")
                  
                  clip_id = clip['clip_id']
                  video_file = TEMP_DIR / f"{clip_id}.mp4"
                  thumbnail_base = TEMP_DIR / f"{clip_id}_base.jpg"
                  thumbnail_final = TEMP_DIR / f"{clip_id}_thumbnail.png"
                  
                  # 1. Capturar frame para thumbnail
                  if not capture_thumbnail_frame(VOD_URL, clip['thumbnail_timestamp'], thumbnail_base):
                      print(f"‚ö†Ô∏è Pulando clipe {clip_id} - erro ao capturar thumbnail")
                      continue
                  
                  # 2. Baixar segmento do v√≠deo
                  if not download_clip_segment(VOD_URL, clip['start_time'], clip['end_time'], video_file):
                      print(f"‚ö†Ô∏è Pulando clipe {clip_id} - erro no download")
                      continue
                  
                  # Verificar se arquivo existe
                  if not video_file.exists():
                      print(f"‚ö†Ô∏è Arquivo {video_file} n√£o foi criado")
                      continue
                  
                  file_size = video_file.stat().st_size / (1024*1024)
                  print(f"‚úÖ V√≠deo baixado: {file_size:.2f} MB")
                  
                  # Salvar informa√ß√µes para pr√≥ximas etapas
                  clips_info.append({
                      'clip': clip,
                      'video_file': str(video_file),
                      'thumbnail_base': str(thumbnail_base),
                      'thumbnail_final': str(thumbnail_final),
                      'index': idx,
                      'total': len(clips)
                  })
              
              # Salvar informa√ß√µes dos clipes processados
              with open('clips_to_upload.json', 'w', encoding='utf-8') as f:
                  json.dump(clips_info, f, indent=2, ensure_ascii=False)
              
              print(f"\n‚úÖ {len(clips_info)} clipes prontos para upload!")

          if __name__ == '__main__':
              main()
          PYTHON_SCRIPT_EOF

          cat > generate_thumbnails.py << 'PYTHON_SCRIPT_EOF'
          import os
          import re
          import time
          import pickle
          import base64
          import json
          import requests
          from datetime import datetime, timezone
          from pathlib import Path
          from google.auth.transport.requests import Request
          from googleapiclient.discovery import build
          from playwright.sync_api import sync_playwright, Page, Browser

          # Configura√ß√µes
          EMAIL_ADDRESS = "expulsion-flip-elk@duck.com"
          TOKEN_PICKLE = "config_data/gmail_token.pkl"
          CHATGPT_URL = "https://chatgpt.com/"
          HEADLESS = True
          TIMEOUT = 60000
          CLIPS_INFO_FILE = "clips_to_upload.json"

          def get_gmail_service():
              """Carrega as credenciais do pickle e retorna o servi√ßo Gmail"""
              if not os.path.exists(TOKEN_PICKLE):
                  raise FileNotFoundError(f"‚ùå Arquivo '{TOKEN_PICKLE}' n√£o encontrado!")
              
              with open(TOKEN_PICKLE, 'rb') as token:
                  creds = pickle.load(token)
              
              if creds and creds.expired and creds.refresh_token:
                  print("üîÑ Renovando token do Gmail...")
                  creds.refresh(Request())
                  with open(TOKEN_PICKLE, 'wb') as token:
                      pickle.dump(creds, token)
              
              return build('gmail', 'v1', credentials=creds)

          def get_chatgpt_code(service, max_attempts=30, interval=2):
              """Aguarda e extrai o c√≥digo de verifica√ß√£o do ChatGPT do email."""
              print("üìß Aguardando email com c√≥digo do ChatGPT...")
              
              start_time = datetime.now(timezone.utc)
              
              for attempt in range(max_attempts):
                  print(f"   Tentativa {attempt + 1}/{max_attempts}...", end="\r")
                  
                  query = "from:noreply@tm.openai.com subject:Your ChatGPT code is"
                  results = service.users().messages().list(
                      userId='me',
                      q=query,
                      maxResults=5
                  ).execute()
                  
                  messages = results.get('messages', [])
                  
                  for msg in messages:
                      message = service.users().messages().get(
                          userId='me',
                          id=msg['id'],
                          format='full'
                      ).execute()
                      
                      internal_date = int(message.get('internalDate', 0)) / 1000
                      email_time = datetime.fromtimestamp(internal_date, tz=timezone.utc)
                      
                      if email_time < start_time:
                          continue
                      
                      headers = message['payload'].get('headers', [])
                      subject = next(
                          (h['value'] for h in headers if h['name'].lower() == 'subject'),
                          ''
                      )
                      
                      match = re.search(r'Your ChatGPT code is (\d{6})', subject)
                      if match:
                          code = match.group(1)
                          print(f"\n‚úÖ C√≥digo encontrado: {code}")
                          return code
                  
                  time.sleep(interval)
              
              raise TimeoutError("‚ùå Tempo esgotado aguardando o email com o c√≥digo.")

          def mark_email_as_read(service, subject_contains="Your ChatGPT code is"):
              """Marca os emails de c√≥digo como lidos"""
              query = f"from:noreply@tm.openai.com subject:{subject_contains} is:unread"
              results = service.users().messages().list(userId='me', q=query).execute()
              
              for msg in results.get('messages', []):
                  service.users().messages().modify(
                      userId='me',
                      id=msg['id'],
                      body={'removeLabelIds': ['UNREAD']}
                  ).execute()

          def download_image_direct(url, cookies, user_agent, output_path):
              """Baixa a imagem usando as cookies da sess√£o"""
              cookie_str = "; ".join([f"{c['name']}={c['value']}" for c in cookies])
              
              headers = {
                  "Cookie": cookie_str,
                  "User-Agent": user_agent,
                  "Referer": "https://chatgpt.com/"
              }
              
              response = requests.get(url, headers=headers, stream=True)
              
              if response.status_code == 200:
                  with open(output_path, 'wb') as f:
                      for chunk in response.iter_content(chunk_size=8192):
                          f.write(chunk)
                  return True
              return False

          def generate_thumbnail(clip_info, browser, is_first=False):
              """Gera thumbnail para um clipe espec√≠fico"""
              clip = clip_info['clip']
              image_path = os.path.abspath(clip_info['thumbnail_base'])
              output_path = clip_info['thumbnail_final']
              
              print(f"\n{'='*60}")
              print(f"üé® GERANDO THUMBNAIL {clip_info['index']}/{clip_info['total']}")
              print(f"{'='*60}")
              print(f"üé¨ Clipe: {clip['title']}")
              
              if not os.path.exists(image_path):
                  print(f"‚ùå Imagem base n√£o encontrada: {image_path}")
                  return False
              
              # Criar prompt com informa√ß√µes do clipe
              prompt = f"""transforme em uma thumbnail para youtube, esse √© o clipe:
          {{
            "title": "{clip['title']}",
            "category": "{clip['category']}",
            "thumbnail_text": "{clip['thumbnail_text']}",
            "reason": "{clip['reason']}"
          }}"""
              
              context = browser.new_context(
                  no_viewport=True,
                  accept_downloads=True,
                  user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                  locale='en-US',
              )
              
              page = context.new_page()
              page.set_default_timeout(TIMEOUT)
              
              try:
                  if is_first:
                      # Fazer login apenas na primeira vez
                      print("üîê Fazendo login no ChatGPT...")
                      gmail_service = get_gmail_service()
                      
                      page.goto(CHATGPT_URL, wait_until='networkidle')
                      
                      login_button = page.locator('[data-testid="login-button"]')
                      login_button.wait_for(state='visible')
                      login_button.click()
                      
                      email_input = page.locator('input[name="email"]')
                      email_input.wait_for(state='visible')
                      email_input.click()
                      time.sleep(0.3)
                      email_input.fill(EMAIL_ADDRESS)
                      
                      continue_button = page.locator('button[type="submit"]:has-text("Continue")')
                      continue_button.wait_for(state='visible')
                      time.sleep(0.5)
                      continue_button.click()
                      
                      code = get_chatgpt_code(gmail_service)
                      
                      code_input = page.locator('input[name="code"]')
                      code_input.wait_for(state='visible')
                      time.sleep(0.5)
                      code_input.click()
                      code_input.fill(code)
                      
                      validate_button = page.locator('button[name="intent"][value="validate"]')
                      validate_button.wait_for(state='visible')
                      time.sleep(0.3)
                      validate_button.click()
                      
                      page.wait_for_url("**/", timeout=30000)
                      time.sleep(3)
                      
                      print("‚úÖ Login realizado!")
                      mark_email_as_read(gmail_service)
                  else:
                      # J√° est√° logado, apenas acessar
                      page.goto(CHATGPT_URL, wait_until='domcontentloaded')
                      time.sleep(2)
                  
                  # Criar nova imagem
                  print("üé® Criando imagem...")
                  plus_btn = page.locator('[data-testid="composer-plus-btn"]')
                  plus_btn.wait_for(state="visible", timeout=15000)
                  plus_btn.click()
                  time.sleep(1)
                  
                  create_image_btn = page.locator('div[role="menuitemradio"]:has-text("Create image")')
                  create_image_btn.wait_for(state="visible", timeout=5000)
                  create_image_btn.click()
                  time.sleep(2)
                  
                  # Adicionar imagem base
                  print("üì§ Adicionando imagem base...")
                  file_input = page.locator('input[type="file"]').first
                  file_input.set_input_files(image_path)
                  time.sleep(2)
                  
                  # Inserir prompt
                  print("üìù Inserindo prompt...")
                  textarea = page.locator('#prompt-textarea')
                  textarea.wait_for(state="visible", timeout=5000)
                  textarea.click()
                  time.sleep(0.5)
                  
                  # Escapar aspas no prompt para JavaScript
                  escaped_prompt = prompt.replace('"', '\\"').replace('\n', '\\n')
                  
                  page.evaluate(f'''
                      () => {{
                          const textarea = document.querySelector('#prompt-textarea');
                          if (!textarea) return;
                          const p = textarea.querySelector('p');
                          if (p) {{
                              p.textContent = `{escaped_prompt}`;
                          }} else {{
                              textarea.innerHTML = `<p>{escaped_prompt}</p>`;
                          }}
                          textarea.dispatchEvent(new Event('input', {{ bubbles: true }}));
                      }}
                  ''')
                  time.sleep(1)
                  
                  # Enviar
                  print("üöÄ Gerando thumbnail...")
                  send_btn = page.locator('#composer-submit-button')
                  send_btn.wait_for(state="visible", timeout=5000)
                  send_btn.click()
                  
                  # Aguardar gera√ß√£o
                  print("‚è≥ Aguardando gera√ß√£o (4 minutos)...")
                  time.sleep(240)
                  
                  # Baixar imagem
                  print("üíæ Baixando thumbnail...")
                  image_containers = page.locator('div[class*="group/imagegen-image"]').all()
                  
                  if len(image_containers) > 0:
                      last_container = image_containers[-1]
                      last_container.hover()
                      time.sleep(1)
                      
                      download_btn = last_container.locator('button[aria-label="Download this image"]')
                      download_btn.wait_for(state="visible", timeout=5000)
                      
                      with page.expect_download(timeout=60000) as download_info:
                          download_btn.click()
                      
                      download = download_info.value
                      download.save_as(output_path)
                      
                      print(f"‚úÖ Thumbnail salva: {output_path}")
                      context.close()
                      return True
                  else:
                      print("‚ùå Nenhuma imagem gerada encontrada")
                      context.close()
                      return False
                  
              except Exception as e:
                  print(f"‚ùå Erro ao gerar thumbnail: {e}")
                  context.close()
                  return False

          def main():
              print("üé® GERADOR DE THUMBNAILS PARA YOUTUBE")
              print("="*60)
              
              # Carregar informa√ß√µes dos clipes
              with open(CLIPS_INFO_FILE, 'r', encoding='utf-8') as f:
                  clips_info = json.load(f)
              
              if not clips_info:
                  print("‚ö†Ô∏è Nenhum clipe para processar")
                  return
              
              print(f"üìä {len(clips_info)} thumbnails para gerar")
              
              with sync_playwright() as p:
                  browser = p.chromium.launch(
                      headless=HEADLESS,
                      args=[
                          '--start-maximized',
                          '--disable-blink-features=AutomationControlled',
                          '--no-sandbox',
                          '--disable-dev-shm-usage',
                      ]
                  )
                  
                  success_count = 0
                  
                  for idx, clip_info in enumerate(clips_info):
                      is_first = (idx == 0)
                      
                      if generate_thumbnail(clip_info, browser, is_first):
                          success_count += 1
                      else:
                          print(f"‚ö†Ô∏è Falha ao gerar thumbnail para {clip_info['clip']['clip_id']}")
                      
                      # Pequena pausa entre gera√ß√µes
                      if idx < len(clips_info) - 1:
                          print("\n‚è∏Ô∏è  Pausa de 10 segundos...\n")
                          time.sleep(10)
                  
                  browser.close()
              
              print(f"\n‚úÖ {success_count}/{len(clips_info)} thumbnails geradas com sucesso!")

          if __name__ == "__main__":
              main()
          PYTHON_SCRIPT_EOF

          cat > upload_to_youtube.py << 'PYTHON_SCRIPT_EOF'
          import os
          import json
          import pickle
          import random
          from pathlib import Path
          from google.oauth2.credentials import Credentials
          from googleapiclient.discovery import build
          from googleapiclient.http import MediaFileUpload
          from google.auth.transport.requests import Request

          CLIPS_INFO_FILE = "clips_to_upload.json"
          YOUTUBE_ACCOUNTS_DIR = "youtube_accounts"

          def load_youtube_credentials():
              """Carrega credenciais de uma conta YouTube aleat√≥ria"""
              accounts_dir = Path(YOUTUBE_ACCOUNTS_DIR)
              json_files = list(accounts_dir.glob("*.json"))
              
              if not json_files:
                  raise FileNotFoundError("‚ùå Nenhuma conta YouTube encontrada!")
              
              # Escolher arquivo aleat√≥rio
              selected_file = random.choice(json_files)
              
              print(f"üì∫ Usando conta: {selected_file.name}")
              
              with open(selected_file, 'r') as f:
                  account_data = json.load(f)
              
              # Procurar arquivo PKL correspondente
              pkl_file = account_data.get('pkl_file')
              if not pkl_file:
                  raise ValueError("‚ùå pkl_file n√£o encontrado no JSON")
              
              pkl_path = accounts_dir / pkl_file
              
              if not pkl_path.exists():
                  raise FileNotFoundError(f"‚ùå Arquivo PKL n√£o encontrado: {pkl_path}")
              
              # Carregar credenciais do pickle
              with open(pkl_path, 'rb') as token:
                  creds = pickle.load(token)
              
              # Renovar se necess√°rio
              if creds and creds.expired and creds.refresh_token:
                  print("üîÑ Renovando token do YouTube...")
                  creds.refresh(Request())
                  with open(pkl_path, 'wb') as token:
                      pickle.dump(creds, token)
              
              return creds, account_data['channel_info']

          def upload_video(youtube, video_file, clip_data, thumbnail_file):
              """Faz upload de um v√≠deo para o YouTube"""
              
              clip = clip_data['clip']
              
              # Preparar metadados
              title = clip['title'][:100]  # YouTube limita a 100 caracteres
              description = clip.get('recommended_description', '')
              tags = clip.get('tags', [])[:500]  # YouTube limita tags
              
              body = {
                  'snippet': {
                      'title': title,
                      'description': description,
                      'tags': tags,
                      'categoryId': '20'  # Gaming category
                  },
                  'status': {
                      'privacyStatus': 'private',  # Sempre privado
                      'selfDeclaredMadeForKids': False,
                  }
              }
              
              # Upload do v√≠deo
              print(f"üì§ Fazendo upload: {title}")
              
              media = MediaFileUpload(
                  video_file,
                  chunksize=10*1024*1024,  # 10MB chunks
                  resumable=True,
                  mimetype='video/mp4'
              )
              
              request = youtube.videos().insert(
                  part='snippet,status',
                  body=body,
                  media_body=media
              )
              
              response = None
              retry_count = 0
              max_retries = 3
              
              while response is None and retry_count < max_retries:
                  try:
                      print(f"   üìä Upload em progresso...")
                      status, response = request.next_chunk()
                      
                      if status:
                          progress = int(status.progress() * 100)
                          print(f"   üìä Progresso: {progress}%", end='\r')
                  
                  except Exception as e:
                      print(f"   ‚ö†Ô∏è Erro no upload (tentativa {retry_count + 1}/{max_retries}): {e}")
                      retry_count += 1
                      if retry_count >= max_retries:
                          raise
              
              if not response:
                  raise Exception("‚ùå Upload falhou ap√≥s m√∫ltiplas tentativas")
              
              video_id = response['id']
              print(f"\n‚úÖ V√≠deo enviado! ID: {video_id}")
              
              # Upload da thumbnail
              if thumbnail_file and Path(thumbnail_file).exists():
                  try:
                      print(f"üñºÔ∏è  Fazendo upload da thumbnail...")
                      youtube.thumbnails().set(
                          videoId=video_id,
                          media_body=MediaFileUpload(thumbnail_file)
                      ).execute()
                      print(f"‚úÖ Thumbnail definida!")
                  except Exception as e:
                      print(f"‚ö†Ô∏è Erro ao definir thumbnail: {e}")
              
              return video_id

          def main():
              print("üì∫ UPLOAD PARA YOUTUBE")
              print("="*60)
              
              # Carregar informa√ß√µes dos clipes
              with open(CLIPS_INFO_FILE, 'r', encoding='utf-8') as f:
                  clips_info = json.load(f)
              
              if not clips_info:
                  print("‚ö†Ô∏è Nenhum clipe para fazer upload")
                  return
              
              print(f"üìä {len(clips_info)} v√≠deos para upload")
              
              # Carregar credenciais
              creds, channel_info = load_youtube_credentials()
              youtube = build('youtube', 'v3', credentials=creds)
              
              print(f"‚úÖ Autenticado no canal: {channel_info['title']}")
              print(f"üìä Inscritos: {channel_info['subscribers']}")
              
              uploaded_videos = []
              
              for idx, clip_info in enumerate(clips_info, 1):
                  print(f"\n{'='*60}")
                  print(f"üì§ UPLOAD {idx}/{len(clips_info)}")
                  print(f"{'='*60}")
                  
                  video_file = clip_info['video_file']
                  thumbnail_file = clip_info.get('thumbnail_final')
                  
                  # Verificar se arquivo existe
                  if not Path(video_file).exists():
                      print(f"‚ö†Ô∏è Arquivo n√£o encontrado: {video_file}")
                      continue
                  
                  try:
                      video_id = upload_video(youtube, video_file, clip_info, thumbnail_file)
                      
                      uploaded_videos.append({
                          'clip_id': clip_info['clip']['clip_id'],
                          'video_id': video_id,
                          'title': clip_info['clip']['title'],
                          'url': f"https://youtube.com/watch?v={video_id}"
                      })
                      
                      # Limpar arquivos ap√≥s upload
                      print("üóëÔ∏è  Limpando arquivos tempor√°rios...")
                      try:
                          Path(video_file).unlink()
                          if thumbnail_file and Path(thumbnail_file).exists():
                              Path(thumbnail_file).unlink()
                          base_thumb = clip_info.get('thumbnail_base')
                          if base_thumb and Path(base_thumb).exists():
                              Path(base_thumb).unlink()
                          print("‚úÖ Arquivos removidos")
                      except Exception as e:
                          print(f"‚ö†Ô∏è Erro ao limpar: {e}")
                      
                  except Exception as e:
                      print(f"‚ùå Erro no upload: {e}")
                      continue
              
              # Salvar relat√≥rio
              with open('upload_report.json', 'w', encoding='utf-8') as f:
                  json.dump(uploaded_videos, f, indent=2, ensure_ascii=False)
              
              print(f"\n{'='*60}")
              print(f"‚úÖ PROCESSO CONCLU√çDO!")
              print(f"{'='*60}")
              print(f"üìä {len(uploaded_videos)}/{len(clips_info)} v√≠deos enviados")
              print(f"üìÑ Relat√≥rio salvo em: upload_report.json")
              
              for video in uploaded_videos:
                  print(f"\nüé¨ {video['title']}")
                  print(f"   üîó {video['url']}")

          if __name__ == "__main__":
              main()
          PYTHON_SCRIPT_EOF

          echo "‚úÖ Scripts criados com sucesso!"

      - name: üé¨ Processar e Baixar Clipes
        run: |
          python process_clips.py

      - name: üé® Gerar Thumbnails
        run: |
          python generate_thumbnails.py

      - name: üì∫ Upload para YouTube
        run: |
          python upload_to_youtube.py

      - name: üìä Exibir Relat√≥rio Final
        if: always()
        run: |
          if [ -f upload_report.json ]; then
            echo "üìä RELAT√ìRIO DE UPLOADS"
            echo "======================="
            cat upload_report.json
          else
            echo "‚ö†Ô∏è Nenhum upload realizado"
          fi

      - name: üì§ Upload do Relat√≥rio
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: upload-report
          path: |
            upload_report.json
            clips_to_upload.json
          retention-days: 30

      - name: üßπ Limpeza Final
        if: always()
        run: |
          echo "üßπ Limpando arquivos tempor√°rios..."
          rm -rf temp_processing
          rm -rf config_data
          rm -rf youtube_accounts
          echo "‚úÖ Limpeza conclu√≠da!"
