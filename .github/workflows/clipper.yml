name: üé¨ Create YouTube Clips

on:
  workflow_dispatch:
    inputs:
      vod_link:
        description: 'üîó Link do VOD da Twitch'
        required: true
        type: string
      password:
        description: 'üîê Senha para executar'
        required: true
        type: string

env:
  PYTHONUNBUFFERED: "1"

jobs:
  validate:
    name: üîê Validar Senha
    runs-on: ubuntu-latest
    outputs:
      valid: ${{ steps.check.outputs.valid }}
    steps:
      - name: Verificar senha
        id: check
        run: |
          if [ "${{ github.event.inputs.password }}" = "${{ secrets.SENHA }}" ]; then
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Senha v√°lida!"
          else
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "‚ùå Senha inv√°lida!"
            exit 1
          fi

  create-clips:
    name: üé¨ Processar Clipes
    needs: validate
    if: needs.validate.outputs.valid == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 360
    
    steps:
      - name: üì• Checkout do reposit√≥rio
        uses: actions/checkout@v4

      - name: üìù Criar requirements.txt
        run: |
          cat > requirements.txt << 'EOF'
          google-api-python-client>=2.100.0
          google-auth>=2.23.0
          google-auth-oauthlib>=1.1.0
          google-auth-httplib2>=0.1.1
          requests>=2.31.0
          yt-dlp>=2024.1.0
          Pillow>=10.0.0
          EOF
          echo "‚úÖ requirements.txt criado!"

      - name: üêç Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: üì¶ Instalar depend√™ncias do sistema
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg aria2
          aria2c --version | head -1
          
      - name: üì¶ Instalar depend√™ncias Python
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: üì• Baixar configura√ß√µes do reposit√≥rio externo
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          echo "üì• Baixando analise_resultado.json..."
          curl -H "Authorization: token $GH_PAT" \
               -H "Accept: application/vnd.github.v3.raw" \
               -o analise_resultado.json \
               "https://api.github.com/repos/Alisson990jd/apiss/contents/analise_resultado.json"
          
          echo "üì• Baixando gmail_token.pkl..."
          curl -H "Authorization: token $GH_PAT" \
               -H "Accept: application/vnd.github.v3.raw" \
               -o gmail_token.pkl \
               "https://api.github.com/repos/Alisson990jd/apiss/contents/gmail_token.pkl"
          
          echo "üì• Baixando arquivos da pasta analisar..."
          mkdir -p analisar
          
          FILES=$(curl -s -H "Authorization: token $GH_PAT" \
                       -H "Accept: application/vnd.github.v3+json" \
                       "https://api.github.com/repos/Alisson990jd/apiss/contents/analisar" | \
                  jq -r '.[] | select(.name | endswith(".json")) | .name')
          
          for FILE in $FILES; do
            echo "  üìÑ Baixando $FILE..."
            curl -s -H "Authorization: token $GH_PAT" \
                 -H "Accept: application/vnd.github.v3.raw" \
                 -o "analisar/$FILE" \
                 "https://api.github.com/repos/Alisson990jd/apiss/contents/analisar/$FILE"
          done
          
          PKL_FILES=$(curl -s -H "Authorization: token $GH_PAT" \
                       -H "Accept: application/vnd.github.v3+json" \
                       "https://api.github.com/repos/Alisson990jd/apiss/contents/analisar" | \
                  jq -r '.[] | select(.name | endswith(".pkl")) | .name')
          
          for FILE in $PKL_FILES; do
            echo "  üìÑ Baixando $FILE..."
            curl -s -H "Authorization: token $GH_PAT" \
                 -H "Accept: application/vnd.github.v3.raw" \
                 -o "analisar/$FILE" \
                 "https://api.github.com/repos/Alisson990jd/apiss/contents/analisar/$FILE"
          done
          
          echo "‚úÖ Configura√ß√µes baixadas!"
          ls -la analisar/

      - name: üìÇ Criar diret√≥rios
        run: |
          mkdir -p scripts temp_clips thumbnails

      - name: üìù Criar script otimizado
        run: |
          cat > scripts/clip_creator.py << 'SCRIPT_EOF'
          #!/usr/bin/env python3
          """
          üé¨ YouTube Clip Creator - COM THUMBNAIL CORRIGIDA
          """

          import os
          import sys
          import json
          import subprocess
          import pickle
          import time
          import logging
          from pathlib import Path
          from datetime import datetime
          from typing import Optional, Dict, List

          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s | %(levelname)s | %(message)s',
              handlers=[
                  logging.StreamHandler(sys.stdout),
                  logging.FileHandler('clip_creator.log')
              ]
          )
          logger = logging.getLogger(__name__)

          TEMP_DIR = Path("temp_clips")
          THUMB_DIR = Path("thumbnails")
          PROCESSING_LOG = "processing_log.json"


          def time_to_seconds(time_str: str) -> int:
              parts = time_str.split(':')
              if len(parts) == 3:
                  h, m, s = map(int, parts)
                  return h * 3600 + m * 60 + s
              elif len(parts) == 2:
                  m, s = map(int, parts)
                  return m * 60 + s
              return int(parts[0])


          def seconds_to_time(seconds: int) -> str:
              h = seconds // 3600
              m = (seconds % 3600) // 60
              s = seconds % 60
              return f"{h:02d}:{m:02d}:{s:02d}"


          def load_clips_config() -> List[Dict]:
              logger.info("üìÇ Carregando configura√ß√£o de clipes...")
              with open("analise_resultado.json", "r", encoding="utf-8") as f:
                  data = json.load(f)
              clips = data.get("clips", [])
              youtube_clips = [c for c in clips if c.get("platform") == "youtube"]
              logger.info(f"   Total: {len(clips)} | YouTube: {len(youtube_clips)}")
              return youtube_clips


          def load_youtube_credentials() -> Dict:
              logger.info("üîë Carregando credenciais...")
              analisar_dir = Path("analisar")
              json_files = list(analisar_dir.glob("*.json"))
              if not json_files:
                  raise FileNotFoundError("Nenhuma credencial encontrada!")
              
              cred_file = json_files[0]
              with open(cred_file, "r", encoding="utf-8") as f:
                  cred_data = json.load(f)
              
              pkl_files = list(analisar_dir.glob("*.pkl"))
              if not pkl_files:
                  raise FileNotFoundError("Arquivo pkl n√£o encontrado!")
              
              logger.info(f"   ‚úÖ Usando: {pkl_files[0].name}")
              return {"json_data": cred_data, "pkl_file": pkl_files[0]}


          def download_clip_segment_fast(vod_url: str, start_time: str, end_time: str, output_path: Path) -> bool:
              """Download ULTRA R√ÅPIDO usando aria2c"""
              logger.info(f"‚¨áÔ∏è  Download: {start_time} -> {end_time}")
              
              aria2_args = [
                  "--max-connection-per-server=16",
                  "--split=16",
                  "--min-split-size=1M",
                  "--max-concurrent-downloads=16",
                  "--file-allocation=none",
                  "--continue=true",
                  "--max-tries=5",
                  "--retry-wait=2",
                  "--timeout=60",
                  "--connect-timeout=30",
                  "--console-log-level=warn",
              ]
              
              cmd = [
                  "yt-dlp",
                  "--format", "bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo+bestaudio/best",
                  "--download-sections", f"*{start_time}-{end_time}",
                  "--downloader", "aria2c",
                  "--downloader-args", f"aria2c:{' '.join(aria2_args)}",
                  "--concurrent-fragments", "16",
                  "--no-part",
                  "--no-mtime",
                  "--no-check-certificates",
                  "--merge-output-format", "mp4",
                  "--output", str(output_path),
                  "--progress",
                  vod_url
              ]
              
              try:
                  start = time.time()
                  result = subprocess.run(cmd, capture_output=True, text=True, timeout=1200)
                  elapsed = time.time() - start
                  
                  if result.returncode == 0 and output_path.exists():
                      size_mb = output_path.stat().st_size / (1024 * 1024)
                      speed = size_mb / elapsed if elapsed > 0 else 0
                      logger.info(f"   ‚úÖ Baixado: {size_mb:.1f}MB em {elapsed:.1f}s ({speed:.1f} MB/s)")
                      return True
                  else:
                      logger.warning(f"   ‚ö†Ô∏è aria2c falhou, tentando fallback...")
                      return download_clip_fallback(vod_url, start_time, end_time, output_path)
                      
              except subprocess.TimeoutExpired:
                  logger.error("   ‚ùå Timeout")
                  return False
              except Exception as e:
                  logger.error(f"   ‚ùå Erro: {e}")
                  return download_clip_fallback(vod_url, start_time, end_time, output_path)


          def download_clip_fallback(vod_url: str, start_time: str, end_time: str, output_path: Path) -> bool:
              """Fallback sem aria2c"""
              cmd = [
                  "yt-dlp",
                  "--format", "best[ext=mp4]/best",
                  "--download-sections", f"*{start_time}-{end_time}",
                  "--concurrent-fragments", "8",
                  "--no-part",
                  "--merge-output-format", "mp4",
                  "--output", str(output_path),
                  vod_url
              ]
              
              try:
                  result = subprocess.run(cmd, capture_output=True, text=True, timeout=1200)
                  if result.returncode == 0 and output_path.exists():
                      size_mb = output_path.stat().st_size / (1024 * 1024)
                      logger.info(f"   ‚úÖ Fallback OK: {size_mb:.1f}MB")
                      return True
                  return False
              except:
                  return False


          def capture_thumbnail(video_path: Path, timestamp: str, output_path: Path) -> bool:
              """
              Captura frame do v√≠deo como thumbnail
              Garante resolu√ß√£o 1280x720 (requerido pelo YouTube)
              """
              logger.info(f"üì∏ Capturando thumbnail em {timestamp}...")
              
              # Primeiro, captura o frame
              temp_frame = output_path.with_suffix('.temp.png')
              
              cmd_capture = [
                  "ffmpeg", "-y",
                  "-ss", timestamp,
                  "-i", str(video_path),
                  "-vframes", "1",
                  "-q:v", "1",  # M√°xima qualidade
                  str(temp_frame)
              ]
              
              try:
                  result = subprocess.run(cmd_capture, capture_output=True, text=True, timeout=30)
                  
                  if result.returncode != 0 or not temp_frame.exists():
                      logger.error(f"   ‚ùå Falha na captura: {result.stderr}")
                      return False
                  
                  # Agora redimensiona para 1280x720 (requisito do YouTube)
                  cmd_resize = [
                      "ffmpeg", "-y",
                      "-i", str(temp_frame),
                      "-vf", "scale=1280:720:force_original_aspect_ratio=decrease,pad=1280:720:(ow-iw)/2:(oh-ih)/2",
                      "-q:v", "1",
                      str(output_path)
                  ]
                  
                  result = subprocess.run(cmd_resize, capture_output=True, text=True, timeout=30)
                  
                  # Remove temp
                  if temp_frame.exists():
                      temp_frame.unlink()
                  
                  if result.returncode == 0 and output_path.exists():
                      size_kb = output_path.stat().st_size / 1024
                      logger.info(f"   ‚úÖ Thumbnail capturada: {size_kb:.1f}KB (1280x720)")
                      return True
                  else:
                      logger.error(f"   ‚ùå Falha no resize: {result.stderr}")
                      return False
                      
              except Exception as e:
                  logger.error(f"   ‚ùå Erro: {e}")
                  return False


          def upload_to_youtube(video_path: Path, thumb_path: Optional[Path], clip_data: Dict, credentials: Dict) -> Optional[str]:
              """Upload para YouTube com thumbnail"""
              logger.info("üì§ Upload para YouTube...")
              
              try:
                  from google.auth.transport.requests import Request
                  from googleapiclient.discovery import build
                  from googleapiclient.http import MediaFileUpload
                  from googleapiclient.errors import HttpError
                  
                  with open(credentials["pkl_file"], 'rb') as f:
                      creds = pickle.load(f)
                  
                  if creds and creds.expired and creds.refresh_token:
                      logger.info("   üîÑ Renovando token...")
                      creds.refresh(Request())
                      with open(credentials["pkl_file"], 'wb') as f:
                          pickle.dump(creds, f)
                  
                  service = build('youtube', 'v3', credentials=creds)
                  
                  # Verificar canal
                  try:
                      channel_response = service.channels().list(part='snippet,status', mine=True).execute()
                      if channel_response.get('items'):
                          channel = channel_response['items'][0]
                          logger.info(f"   üì∫ Canal: {channel['snippet']['title']}")
                  except Exception as e:
                      logger.warning(f"   ‚ö†Ô∏è N√£o foi poss√≠vel verificar canal: {e}")
                  
                  category_map = {"gaming": "20", "entertainment": "24", "IRL": "22", "react": "24"}
                  category_id = category_map.get(clip_data.get("category", "").lower(), "22")
                  
                  title = clip_data.get("title", "Clip")[:100]
                  description = clip_data.get("recommended_description", "")[:5000]
                  tags = clip_data.get("tags", [])[:500]
                  
                  logger.info(f"   üìù T√≠tulo: {title}")
                  
                  body = {
                      'snippet': {
                          'title': title,
                          'description': description,
                          'tags': tags,
                          'categoryId': category_id,
                      },
                      'status': {
                          'privacyStatus': 'private',
                          'selfDeclaredMadeForKids': False,
                      }
                  }
                  
                  # Upload do v√≠deo
                  media = MediaFileUpload(
                      str(video_path), 
                      chunksize=10*1024*1024, 
                      resumable=True, 
                      mimetype='video/mp4'
                  )
                  
                  request = service.videos().insert(
                      part=','.join(body.keys()), 
                      body=body, 
                      media_body=media
                  )
                  
                  response = None
                  while response is None:
                      status, response = request.next_chunk()
                      if status:
                          progress = int(status.progress() * 100)
                          logger.info(f"   üì§ Upload: {progress}%")
                  
                  video_id = response.get('id')
                  
                  if not video_id:
                      logger.error("   ‚ùå Nenhum video_id retornado!")
                      return None
                  
                  logger.info(f"   ‚úÖ V√≠deo enviado: {video_id}")
                  logger.info(f"   üîó https://youtube.com/watch?v={video_id}")
                  
                  # Upload da thumbnail
                  if thumb_path and thumb_path.exists():
                      thumb_size = thumb_path.stat().st_size
                      logger.info(f"   üñºÔ∏è Enviando thumbnail ({thumb_size/1024:.1f}KB)...")
                      
                      if thumb_size < 100:
                          logger.error(f"   ‚ùå Thumbnail muito pequena ({thumb_size} bytes)")
                      else:
                          try:
                              thumb_media = MediaFileUpload(
                                  str(thumb_path), 
                                  mimetype='image/png',
                                  resumable=False
                              )
                              
                              thumb_response = service.thumbnails().set(
                                  videoId=video_id, 
                                  media_body=thumb_media
                              ).execute()
                              
                              if thumb_response:
                                  logger.info(f"   ‚úÖ Thumbnail definida com sucesso!")
                                  logger.info(f"      URL: {thumb_response.get('items', [{}])[0].get('default', {}).get('url', 'N/A')}")
                              else:
                                  logger.warning("   ‚ö†Ô∏è Resposta vazia da API de thumbnail")
                                  
                          except HttpError as e:
                              error_content = e.content.decode() if hasattr(e, 'content') else str(e)
                              logger.error(f"   ‚ùå Erro HTTP ao definir thumbnail: {e.resp.status}")
                              logger.error(f"      Detalhes: {error_content}")
                              
                              if e.resp.status == 403:
                                  logger.error("   ‚ö†Ô∏è O canal pode n√£o ter permiss√£o para thumbnails customizadas")
                                  logger.error("   ‚ö†Ô∏è Verifique se o canal est√° verificado no YouTube")
                              
                          except Exception as e:
                              logger.error(f"   ‚ùå Erro ao definir thumbnail: {type(e).__name__}: {e}")
                  else:
                      logger.warning(f"   ‚ö†Ô∏è Thumbnail n√£o encontrada: {thumb_path}")
                  
                  return video_id
                  
              except HttpError as e:
                  logger.error(f"   ‚ùå Erro HTTP: {e.resp.status} - {e.content.decode()}")
                  return None
              except Exception as e:
                  logger.error(f"   ‚ùå Erro: {type(e).__name__}: {e}")
                  import traceback
                  traceback.print_exc()
                  return None


          def process_clip(clip_data: Dict, vod_url: str, credentials: Dict, idx: int, total: int) -> Dict:
              clip_id = clip_data.get("clip_id", f"clip_{idx}")
              
              logger.info("")
              logger.info("=" * 60)
              logger.info(f"üé¨ [{idx+1}/{total}] {clip_id}")
              logger.info(f"   üìù {clip_data.get('title', 'N/A')[:60]}...")
              logger.info(f"   ‚è±Ô∏è  {clip_data.get('start_time')} ‚Üí {clip_data.get('end_time')}")
              logger.info(f"   üì∏ Thumbnail em: {clip_data.get('thumbnail_timestamp', 'N/A')}")
              logger.info("=" * 60)
              
              result = {
                  "clip_id": clip_id, 
                  "title": clip_data.get("title"), 
                  "status": "pending", 
                  "video_id": None, 
                  "error": None,
                  "thumbnail_status": "pending"
              }
              
              video_path = TEMP_DIR / f"{clip_id}.mp4"
              thumb_path = THUMB_DIR / f"{clip_id}_thumb.png"
              
              try:
                  # 1. Download do clipe
                  if not download_clip_segment_fast(
                      vod_url, 
                      clip_data.get("start_time"), 
                      clip_data.get("end_time"), 
                      video_path
                  ):
                      result["status"] = "failed"
                      result["error"] = "Download falhou"
                      return result
                  
                  # 2. Captura da thumbnail
                  thumb_ts = clip_data.get("thumbnail_timestamp", clip_data.get("start_time"))
                  start_sec = time_to_seconds(clip_data.get("start_time", "00:00:00"))
                  thumb_sec = time_to_seconds(thumb_ts)
                  rel_thumb = seconds_to_time(max(0, thumb_sec - start_sec))
                  
                  thumb_success = capture_thumbnail(video_path, rel_thumb, thumb_path)
                  
                  if thumb_success and thumb_path.exists():
                      result["thumbnail_status"] = "captured"
                      logger.info(f"   ‚úÖ Thumbnail pronta: {thumb_path}")
                  else:
                      result["thumbnail_status"] = "failed"
                      logger.warning(f"   ‚ö†Ô∏è Thumbnail n√£o capturada")
                      thumb_path = None
                  
                  # 3. Upload para YouTube
                  video_id = upload_to_youtube(
                      video_path, 
                      thumb_path if thumb_path and thumb_path.exists() else None, 
                      clip_data, 
                      credentials
                  )
                  
                  if video_id:
                      result["status"] = "success"
                      result["video_id"] = video_id
                      result["url"] = f"https://youtube.com/watch?v={video_id}"
                  else:
                      result["status"] = "failed"
                      result["error"] = "Upload falhou"
                  
              except Exception as e:
                  result["status"] = "error"
                  result["error"] = str(e)
                  logger.error(f"   ‚ùå {e}")
                  import traceback
                  traceback.print_exc()
                  
              finally:
                  # Limpar v√≠deo (manter thumbnail para debug)
                  try:
                      if video_path.exists():
                          video_path.unlink()
                          logger.info(f"   üóëÔ∏è V√≠deo removido")
                  except:
                      pass
              
              return result


          def main():
              logger.info("")
              logger.info("=" * 60)
              logger.info("üé¨ YOUTUBE CLIP CREATOR")
              logger.info("=" * 60)
              
              if len(sys.argv) < 2:
                  logger.error("‚ùå Uso: python clip_creator.py <VOD_URL>")
                  sys.exit(1)
              
              vod_url = sys.argv[1]
              logger.info(f"üìπ VOD: {vod_url}")
              
              TEMP_DIR.mkdir(exist_ok=True)
              THUMB_DIR.mkdir(exist_ok=True)
              
              try:
                  clips = load_clips_config()
                  creds = load_youtube_credentials()
              except Exception as e:
                  logger.error(f"‚ùå {e}")
                  import traceback
                  traceback.print_exc()
                  sys.exit(1)
              
              if not clips:
                  logger.warning("‚ö†Ô∏è Nenhum clipe YouTube!")
                  sys.exit(0)
              
              logger.info(f"üìã {len(clips)} clipes para processar")
              
              results = []
              total = len(clips)
              
              for i, clip in enumerate(clips):
                  result = process_clip(clip, vod_url, creds, i, total)
                  results.append(result)
                  
                  if result["status"] == "success" and i < total - 1:
                      logger.info("‚è≥ Aguardando 5s...")
                      time.sleep(5)
              
              # Salvar log
              summary = {
                  "processed_at": datetime.now().isoformat(),
                  "total": len(results),
                  "success": len([r for r in results if r["status"] == "success"]),
                  "failed": len([r for r in results if r["status"] != "success"]),
                  "thumbnails_ok": len([r for r in results if r.get("thumbnail_status") == "captured"]),
                  "clips": results
              }
              
              with open(PROCESSING_LOG, "w") as f:
                  json.dump(summary, f, indent=2, ensure_ascii=False)
              
              logger.info("")
              logger.info("=" * 60)
              logger.info("üìä RESUMO FINAL")
              logger.info("=" * 60)
              logger.info(f"   üìπ V√≠deos: {summary['success']}/{summary['total']} sucesso")
              logger.info(f"   üñºÔ∏è  Thumbnails: {summary['thumbnails_ok']}/{summary['total']} capturadas")
              logger.info(f"   ‚ùå Falhas: {summary['failed']}")
              logger.info("=" * 60)
              
              # Lista v√≠deos enviados
              logger.info("")
              logger.info("üì∫ V√çDEOS ENVIADOS:")
              for r in results:
                  if r["status"] == "success":
                      logger.info(f"   ‚úÖ {r['title'][:50]}...")
                      logger.info(f"      {r.get('url', 'N/A')}")


          if __name__ == "__main__":
              main()
          SCRIPT_EOF
          
          chmod +x scripts/clip_creator.py

      - name: üé¨ Processar Clipes
        env:
          VOD_LINK: ${{ github.event.inputs.vod_link }}
        run: |
          python scripts/clip_creator.py "$VOD_LINK"

      - name: üìä Resumo
        if: always()
        run: |
          echo "## üìä Resumo" >> $GITHUB_STEP_SUMMARY
          if [ -f "processing_log.json" ]; then
            echo '```json' >> $GITHUB_STEP_SUMMARY
            cat processing_log.json >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üñºÔ∏è Thumbnails" >> $GITHUB_STEP_SUMMARY
          ls -la thumbnails/ 2>/dev/null || echo "Nenhuma thumbnail encontrada"

      - name: üì§ Upload logs e thumbnails
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: logs-and-thumbnails
          path: |
            *.log
            processing_log.json
            thumbnails/
          retention-days: 7
