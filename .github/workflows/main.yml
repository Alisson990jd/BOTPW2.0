name: "ߔ Reset Gemini API Keys (Parallel)"

on:
  workflow_dispatch:
  schedule:
    - cron: "0 */6 * * *"

permissions:
  contents: write

jobs:
  reset-keys:
    runs-on: ubuntu-latest
    timeout-minutes: 120

    steps:
      - name: Checkout apiss repo
        uses: actions/checkout@v4
        with:
          repository: Alisson990jd/apiss
          token: ${{ secrets.GH_PAT }}
          ref: main

      - name: Debug - listar arquivos
        run: |
          echo "ߓ Raiz:"
          ls -la
          echo ""
          echo "ߓ tokens/:"
          ls -la tokens/ 2>/dev/null || echo "NÃO encontrada"

      - name: Reset all Gemini API Keys (5 workers)
        shell: bash
        run: |
          set +e

          RATE_LIMIT_SLEEP=4
          OP_POLL_INTERVAL=4
          OP_MAX_ATTEMPTS=20
          ENABLE_API_WAIT=8
          MAX_WORKERS=5

          WORK_DIR=$(mktemp -d)
          RESULTS_DIR="$WORK_DIR/results"
          KEYS_DIR="$WORK_DIR/keys"
          LOGS_DIR="$WORK_DIR/logs"
          QUEUE_DIR="$WORK_DIR/queue"
          mkdir -p "$RESULTS_DIR" "$KEYS_DIR" "$LOGS_DIR" "$QUEUE_DIR"

          # ══════════════════════════════════════════
          #  Funções (exportadas para subshells)
          # ══════════════════════════════════════════

          cat > "$WORK_DIR/functions.sh" <<'FUNCEOF'
          refresh_access_token() {
            local file="$1"
            local refresh_token client_id client_secret token_uri

            refresh_token=$(jq -r '.refresh_token // empty' "$file")
            client_id=$(jq -r '.client_id // empty' "$file")
            client_secret=$(jq -r '.client_secret // empty' "$file")
            token_uri=$(jq -r '.token_uri // "https://oauth2.googleapis.com/token"' "$file")

            if [ -z "$refresh_token" ] || [ -z "$client_id" ] || [ -z "$client_secret" ]; then
              echo ""
              return 1
            fi

            local response
            response=$(curl -sS --max-time 30 -X POST "$token_uri" \
              -H "Content-Type: application/x-www-form-urlencoded" \
              -d "client_id=${client_id}&client_secret=${client_secret}&refresh_token=${refresh_token}&grant_type=refresh_token" 2>/dev/null)

            local access_token
            access_token=$(echo "$response" | jq -r '.access_token // empty')

            if [ -z "$access_token" ]; then
              echo ""
              return 1
            fi

            echo "$access_token"
          }

          enable_api() {
            local token="$1" project="$2" api="$3"
            curl -sS --max-time 30 -X POST \
              -H "Authorization: Bearer $token" \
              -H "Content-Type: application/json" \
              "https://serviceusage.googleapis.com/v1/projects/${project}/services/${api}:enable" \
              -d '{}' >/dev/null 2>&1
          }

          wait_for_operation() {
            local token="$1" operation_name="$2"
            local poll_interval="${3:-4}" max_attempts="${4:-20}"

            for attempt in $(seq 1 "$max_attempts"); do
              sleep "$poll_interval"
              local result
              result=$(curl -sS --max-time 30 \
                -H "Authorization: Bearer $token" \
                "https://apikeys.googleapis.com/v2/${operation_name}" 2>/dev/null)

              local done_status
              done_status=$(echo "$result" | jq -r '.done // false')

              if [ "$done_status" = "true" ]; then
                local err
                err=$(echo "$result" | jq -r '.error.code // empty')
                if [ -n "$err" ] && [ "$err" != "null" ]; then
                  echo ""
                  return 1
                fi
                echo "$result"
                return 0
              fi
            done
            echo ""
            return 1
          }

          delete_api_key() {
            local token="$1" key_name="$2"
            local resp
            resp=$(curl -sS --max-time 30 -X DELETE \
              -H "Authorization: Bearer $token" \
              "https://apikeys.googleapis.com/v2/${key_name}" 2>/dev/null)

            local op_name
            op_name=$(echo "$resp" | jq -r '.name // empty')
            [ -n "$op_name" ] && sleep 2 && return 0
            return 1
          }

          create_gemini_key() {
            local token="$1" project_id="$2"
            local display_name="gemini-auto-$(date +%s)-$RANDOM"

            local resp
            resp=$(curl -sS --max-time 30 -X POST \
              -H "Authorization: Bearer $token" \
              -H "Content-Type: application/json" \
              "https://apikeys.googleapis.com/v2/projects/${project_id}/locations/global/keys" \
              -d "{
                \"displayName\": \"${display_name}\",
                \"restrictions\": {
                  \"apiTargets\": [
                    {\"service\": \"generativelanguage.googleapis.com\"}
                  ]
                }
              }" 2>/dev/null)

            local op_name
            op_name=$(echo "$resp" | jq -r '.name // empty')

            if [ -z "$op_name" ]; then
              echo ""
              return 1
            fi

            local op_result
            op_result=$(wait_for_operation "$token" "$op_name" 4 20)
            if [ -z "$op_result" ]; then
              echo ""
              return 1
            fi

            local key_resource
            key_resource=$(echo "$op_result" | jq -r '.response.name // empty')
            if [ -z "$key_resource" ]; then
              echo ""
              return 1
            fi

            sleep 2
            local key_string_resp
            key_string_resp=$(curl -sS --max-time 30 \
              -H "Authorization: Bearer $token" \
              "https://apikeys.googleapis.com/v2/${key_resource}/keyString" 2>/dev/null)

            local api_key
            api_key=$(echo "$key_string_resp" | jq -r '.keyString // empty')
            echo "$api_key"
          }
          FUNCEOF

          # ══════════════════════════════════════════
          #  Script do worker (processa 1 projeto)
          # ══════════════════════════════════════════

          cat > "$WORK_DIR/worker.sh" <<'WORKEREOF'
          #!/bin/bash
          set +e

          source "$1"  # functions.sh

          ACCESS_TOKEN="$2"
          PROJECT_ID="$3"
          RESULT_FILE="$4"
          KEY_FILE="$5"
          LOG_FILE="$6"
          RATE_LIMIT_SLEEP="$7"
          ENABLE_API_WAIT="$8"
          ACCOUNT="$9"

          exec > >(tee -a "$LOG_FILE") 2>&1

          echo "  ┌─ ߓ [$ACCOUNT] Projeto: $PROJECT_ID"
          echo "  │  ߔ Habilitando APIs..."

          enable_api "$ACCESS_TOKEN" "$PROJECT_ID" "apikeys.googleapis.com"
          enable_api "$ACCESS_TOKEN" "$PROJECT_ID" "generativelanguage.googleapis.com"

          echo "  │  ⏳ Aguardando propagação (${ENABLE_API_WAIT}s)..."
          sleep "$ENABLE_API_WAIT"

          # ── Listar keys existentes ──
          echo "  │  ߓ Listando keys existentes..."
          KEYS_RESP=$(curl -sS --max-time 30 \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            "https://apikeys.googleapis.com/v2/projects/${PROJECT_ID}/locations/global/keys?pageSize=300" 2>/dev/null)

          KEY_NAMES=$(echo "$KEYS_RESP" | jq -r '.keys[]?.name // empty')
          DELETED=0

          if [ -n "$KEY_NAMES" ]; then
            KEY_COUNT=$(echo "$KEY_NAMES" | wc -l)
            echo "  │  ߔ $KEY_COUNT keys encontradas"

            while IFS= read -r KEY_NAME; do
              [ -z "$KEY_NAME" ] && continue

              KEY_DETAIL=$(curl -sS --max-time 15 \
                -H "Authorization: Bearer $ACCESS_TOKEN" \
                "https://apikeys.googleapis.com/v2/${KEY_NAME}" 2>/dev/null)

              KEY_DISPLAY=$(echo "$KEY_DETAIL" | jq -r '.displayName // "sem-nome"')

              TARGET_TYPE=$(echo "$KEY_DETAIL" | jq -r '
                if (.restrictions.apiTargets // []) | length > 0 then
                  if [.restrictions.apiTargets[].service] | any(. == "generativelanguage.googleapis.com") then
                    "gemini"
                  else
                    "other"
                  end
                else
                  "unrestricted"
                end
              ')

              if [ "$TARGET_TYPE" = "gemini" ] || [ "$TARGET_TYPE" = "unrestricted" ]; then
                echo "  │  ߗ️  Deletando [$TARGET_TYPE]: $KEY_DISPLAY"
                delete_api_key "$ACCESS_TOKEN" "$KEY_NAME"
                DELETED=$((DELETED + 1))
                sleep "$RATE_LIMIT_SLEEP"
              else
                echo "  │  ⏭️  Mantendo (não-Gemini): $KEY_DISPLAY"
              fi
            done <<< "$KEY_NAMES"
          else
            echo "  │  ߓ Nenhuma key existente"
          fi

          # ── Criar nova key ──
          echo "  │  ߔ Criando nova Gemini API key..."
          NEW_KEY=$(create_gemini_key "$ACCESS_TOKEN" "$PROJECT_ID")

          if [ -n "$NEW_KEY" ]; then
            echo "  │  ✅ Key criada: ${NEW_KEY:0:20}..."
            echo "$ACCOUNT|$PROJECT_ID|$NEW_KEY|$DELETED" > "$RESULT_FILE"
            echo "$NEW_KEY" > "$KEY_FILE"
            echo "  └─ ✔️  Projeto concluído (deletadas: $DELETED, criada: 1)"
          else
            echo "  │  ❌ Falha ao criar key"
            echo "$ACCOUNT|$PROJECT_ID|ERRO|$DELETED" > "$RESULT_FILE"
            echo "  └─ ❌ Projeto com erro"
          fi
          WORKEREOF

          chmod +x "$WORK_DIR/worker.sh"

          # ══════════════════════════════════════════
          #  Verificar pasta tokens
          # ══════════════════════════════════════════

          if [ ! -d "tokens" ]; then
            echo "❌ Pasta 'tokens/' não encontrada!"
            ls -la
            exit 1
          fi

          TOKEN_FILES=$(find tokens -name "*.json" -type f 2>/dev/null | sort)

          if [ -z "$TOKEN_FILES" ]; then
            echo "❌ Nenhum .json em tokens/"
            exit 1
          fi

          FILE_COUNT=$(echo "$TOKEN_FILES" | wc -l)
          echo "ߓ Encontrados $FILE_COUNT arquivos de token"
          echo "ߔ Workers paralelos: $MAX_WORKERS"
          echo ""

          # ══════════════════════════════════════════
          #  Fase 1: Coletar todos os projetos
          # ══════════════════════════════════════════

          echo "═══════════════════════════════════════════"
          echo "  FASE 1: Coletando projetos de cada conta"
          echo "═══════════════════════════════════════════"

          source "$WORK_DIR/functions.sh"

          TASK_ID=0
          TOTAL_ACCOUNTS=0

          declare -A ACCOUNT_TOKENS

          while IFS= read -r TOKEN_FILE; do
            ACCOUNT=$(basename "$TOKEN_FILE" .json)
            TOTAL_ACCOUNTS=$((TOTAL_ACCOUNTS + 1))

            echo ""
            echo "╔══════════════════════════════════════════"
            echo "║ ߓ Conta #${TOTAL_ACCOUNTS}: $ACCOUNT"
            echo "╚══════════════════════════════════════════"

            echo "  ߔ Refreshing access token..."
            ACCESS_TOKEN=$(refresh_access_token "$TOKEN_FILE")

            if [ -z "$ACCESS_TOKEN" ]; then
              echo "  ❌ Falha na autenticação - pulando"
              continue
            fi
            echo "  ✅ Autenticado"

            USER_EMAIL=$(curl -sS --max-time 15 \
              -H "Authorization: Bearer $ACCESS_TOKEN" \
              "https://www.googleapis.com/oauth2/v2/userinfo" 2>/dev/null \
              | jq -r '.email // "desconhecido"')
            echo "  ߓ Email: $USER_EMAIL"

            # Guardar token
            echo "$ACCESS_TOKEN" > "$WORK_DIR/${ACCOUNT}.token"

            # Listar projetos
            echo "  ߓ Listando projetos..."
            ALL_PROJECTS=""
            PAGE_TOKEN=""

            while true; do
              URL="https://cloudresourcemanager.googleapis.com/v1/projects?filter=lifecycleState%3AACTIVE&pageSize=500"
              [ -n "$PAGE_TOKEN" ] && URL="${URL}&pageToken=${PAGE_TOKEN}"

              PROJ_RESP=$(curl -sS --max-time 30 \
                -H "Authorization: Bearer $ACCESS_TOKEN" \
                "$URL" 2>/dev/null)

              PAGE_PROJECTS=$(echo "$PROJ_RESP" | jq -r '.projects[]?.projectId // empty')

              if [ -n "$PAGE_PROJECTS" ]; then
                [ -n "$ALL_PROJECTS" ] && ALL_PROJECTS="${ALL_PROJECTS}"$'\n'"${PAGE_PROJECTS}" || ALL_PROJECTS="$PAGE_PROJECTS"
              fi

              PAGE_TOKEN=$(echo "$PROJ_RESP" | jq -r '.nextPageToken // empty')
              [ -z "$PAGE_TOKEN" ] && break
              sleep 1
            done

            if [ -z "$ALL_PROJECTS" ]; then
              echo "  ⚠️  Nenhum projeto encontrado"
              continue
            fi

            PROJ_COUNT=$(echo "$ALL_PROJECTS" | wc -l)
            echo "  ߓ $PROJ_COUNT projetos"

            # Criar tarefas na fila
            while IFS= read -r PROJECT_ID; do
              [ -z "$PROJECT_ID" ] && continue
              TASK_ID=$((TASK_ID + 1))
              echo "${ACCOUNT}|${PROJECT_ID}" > "$QUEUE_DIR/task_${TASK_ID}.txt"
            done <<< "$ALL_PROJECTS"

          done <<< "$TOKEN_FILES"

          TOTAL_TASKS=$TASK_ID
          echo ""
          echo "═══════════════════════════════════════════"
          echo "  FASE 2: Processando $TOTAL_TASKS projetos"
          echo "  Workers: $MAX_WORKERS em paralelo"
          echo "═══════════════════════════════════════════"
          echo ""

          if [ "$TOTAL_TASKS" -eq 0 ]; then
            echo "⚠️  Nenhum projeto para processar"
            echo "Nenhum projeto encontrado" > gemini_keys.txt
            > gemini_keys_only.txt
            exit 0
          fi

          # ══════════════════════════════════════════
          #  Fase 2: Processar com N workers
          # ══════════════════════════════════════════

          ACTIVE_WORKERS=0
          COMPLETED=0
          TASK_FILES=$(find "$QUEUE_DIR" -name "task_*.txt" | sort -V)

          declare -A WORKER_PIDS

          process_task() {
            local task_file="$1"
            local task_num="$2"

            local task_data
            task_data=$(cat "$task_file")
            local account=$(echo "$task_data" | cut -d'|' -f1)
            local project_id=$(echo "$task_data" | cut -d'|' -f2)
            local access_token=$(cat "$WORK_DIR/${account}.token")

            local result_file="$RESULTS_DIR/result_${task_num}.txt"
            local key_file="$KEYS_DIR/key_${task_num}.txt"
            local log_file="$LOGS_DIR/log_${task_num}.txt"

            bash "$WORK_DIR/worker.sh" \
              "$WORK_DIR/functions.sh" \
              "$access_token" \
              "$project_id" \
              "$result_file" \
              "$key_file" \
              "$log_file" \
              "$RATE_LIMIT_SLEEP" \
              "$ENABLE_API_WAIT" \
              "$account" &

            echo $!
          }

          # Dispatcher loop
          TASK_NUM=0

          for TASK_FILE in $TASK_FILES; do
            TASK_NUM=$((TASK_NUM + 1))

            # Esperar se já temos MAX_WORKERS rodando
            while [ $ACTIVE_WORKERS -ge $MAX_WORKERS ]; do
              # Checar quais terminaram
              for pid in "${!WORKER_PIDS[@]}"; do
                if ! kill -0 "$pid" 2>/dev/null; then
                  wait "$pid" 2>/dev/null
                  unset WORKER_PIDS["$pid"]
                  ACTIVE_WORKERS=$((ACTIVE_WORKERS - 1))
                  COMPLETED=$((COMPLETED + 1))
                  echo "  ߓ Progresso: $COMPLETED/$TOTAL_TASKS concluídos ($ACTIVE_WORKERS workers ativos)"
                fi
              done
              [ $ACTIVE_WORKERS -ge $MAX_WORKERS ] && sleep 2
            done

            # Lançar worker
            TASK_DATA=$(cat "$TASK_FILE")
            TASK_ACCOUNT=$(echo "$TASK_DATA" | cut -d'|' -f1)
            TASK_PROJECT=$(echo "$TASK_DATA" | cut -d'|' -f2)
            echo "  ߚ [$TASK_NUM/$TOTAL_TASKS] Lançando: $TASK_ACCOUNT → $TASK_PROJECT"

            PID=$(process_task "$TASK_FILE" "$TASK_NUM")
            WORKER_PIDS["$PID"]=1
            ACTIVE_WORKERS=$((ACTIVE_WORKERS + 1))

            # Pequeno delay entre lançamentos para não sobrecarregar
            sleep 1
          done

          # Esperar todos terminarem
          echo ""
          echo "  ⏳ Aguardando workers restantes..."
          for pid in "${!WORKER_PIDS[@]}"; do
            wait "$pid" 2>/dev/null
            COMPLETED=$((COMPLETED + 1))
            echo "  ߓ Progresso: $COMPLETED/$TOTAL_TASKS concluídos"
          done

          echo ""
          echo "  ✅ Todos os $TOTAL_TASKS projetos processados!"

          # ══════════════════════════════════════════
          #  Fase 3: Coletar resultados
          # ══════════════════════════════════════════

          echo ""
          echo "═══════════════════════════════════════════"
          echo "  FASE 3: Coletando resultados"
          echo "═══════════════════════════════════════════"

          # Exibir logs dos workers
          echo ""
          echo "── Logs dos Workers ──"
          for LOG in $(find "$LOGS_DIR" -name "log_*.txt" | sort -V); do
            cat "$LOG"
          done

          # Montar arquivo final
          OUTPUT="gemini_keys.txt"
          KEYS_ONLY="gemini_keys_only.txt"

          TOTAL_CREATED=0
          TOTAL_DELETED=0
          TOTAL_ERRORS=0

          cat > "$OUTPUT" <<EOF
          ╔══════════════════════════════════════════════════╗
          ║         GEMINI API KEYS - AUTO GENERATED        ║
          ║   $(date -u '+%Y-%m-%d %H:%M:%S UTC')                        ║
          ║   Workers: $MAX_WORKERS | Projetos: $TOTAL_TASKS             ║
          ╚══════════════════════════════════════════════════╝

          EOF

          > "$KEYS_ONLY"

          CURRENT_ACCOUNT=""

          for RESULT in $(find "$RESULTS_DIR" -name "result_*.txt" | sort -V); do
            LINE=$(cat "$RESULT")
            R_ACCOUNT=$(echo "$LINE" | cut -d'|' -f1)
            R_PROJECT=$(echo "$LINE" | cut -d'|' -f2)
            R_KEY=$(echo "$LINE" | cut -d'|' -f3)
            R_DELETED=$(echo "$LINE" | cut -d'|' -f4)

            # Cabeçalho de conta
            if [ "$R_ACCOUNT" != "$CURRENT_ACCOUNT" ]; then
              CURRENT_ACCOUNT="$R_ACCOUNT"
              {
                echo ""
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo "ߓ Conta: $R_ACCOUNT"
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
              } >> "$OUTPUT"
            fi

            TOTAL_DELETED=$((TOTAL_DELETED + R_DELETED))

            if [ "$R_KEY" != "ERRO" ] && [ -n "$R_KEY" ]; then
              echo "  $R_PROJECT = $R_KEY" >> "$OUTPUT"
              echo "$R_KEY" >> "$KEYS_ONLY"
              TOTAL_CREATED=$((TOTAL_CREATED + 1))
            else
              echo "  $R_PROJECT = ❌ ERRO" >> "$OUTPUT"
              TOTAL_ERRORS=$((TOTAL_ERRORS + 1))
            fi
          done

          # Coletar keys soltas (caso result não tenha sido escrito)
          for KFILE in $(find "$KEYS_DIR" -name "key_*.txt" -size +0 2>/dev/null | sort -V); do
            KEY_VAL=$(cat "$KFILE")
            if [ -n "$KEY_VAL" ] && ! grep -qF "$KEY_VAL" "$KEYS_ONLY" 2>/dev/null; then
              echo "$KEY_VAL" >> "$KEYS_ONLY"
            fi
          done

          # Resumo
          {
            echo ""
            echo "╔══════════════════════════════════════════════════╗"
            echo "║                    RESUMO                       ║"
            echo "╠══════════════════════════════════════════════════╣"
            echo "║  Contas processadas:  $TOTAL_ACCOUNTS"
            echo "║  Projetos processados: $TOTAL_TASKS"
            echo "║  Keys deletadas:      $TOTAL_DELETED"
            echo "║  Keys criadas:        $TOTAL_CREATED"
            echo "║  Erros:               $TOTAL_ERRORS"
            echo "║  Workers paralelos:   $MAX_WORKERS"
            echo "║  Gerado em:           $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo "╚══════════════════════════════════════════════════╝"
          } >> "$OUTPUT"

          echo ""
          echo "══════════════════════════════════════════"
          echo "ߓ RESUMO FINAL"
          echo "══════════════════════════════════════════"
          echo "  Contas:    $TOTAL_ACCOUNTS"
          echo "  Projetos:  $TOTAL_TASKS"
          echo "  Deletadas: $TOTAL_DELETED"
          echo "  Criadas:   $TOTAL_CREATED"
          echo "  Erros:     $TOTAL_ERRORS"
          echo "  Workers:   $MAX_WORKERS"
          echo "══════════════════════════════════════════"
          echo ""
          echo "ߓ Arquivo de keys:"
          cat "$OUTPUT"
          echo ""
          echo "ߓ Keys (raw):"
          cat "$KEYS_ONLY"

          # Cleanup
          rm -rf "$WORK_DIR"

      - name: Commit and push keys
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git add gemini_keys.txt gemini_keys_only.txt

          if git diff --cached --quiet; then
            echo "Nenhuma alteração"
          else
            TOTAL=$(wc -l < gemini_keys_only.txt 2>/dev/null || echo 0)
            git commit -m "ߔ Keys resetadas (5 workers) - $(date -u '+%Y-%m-%d %H:%M UTC') | $TOTAL keys"
            git push
            echo "✅ Push realizado!"
          fi
